<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[面试准备]]></title>
      <url>%2F2020%2F04%2F24%2F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%2F</url>
      <content type="text"><![CDATA[htmldoctype作用位于文档最前面，用于告知浏览器用何种文档类型规范来解析这个文档 混杂模式和严格模式严格模式的排版和js运作按照w3c浏览器标准来 运行混杂模式则采用向后兼容的方式运行，模拟老式浏览器的行为防止站点无法工作 意义doctype不存在或者格式不正确则以混杂模式呈现 doctype文档类型 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。HTML和XHTML的区别 所有的标记都必须要有一个相应的结束标记 所有标签的元素和属性的名字都必须使用小写 所有的 XML 标记都必须合理嵌套 所有的属性必须用引号 “” 括起来 把所有 &lt; 和 &amp; 特殊符号用编码表示 给所有属性赋一个值 不要在注释内容中使用 “–” 图片必须有说明文字优雅降级和渐进增强的区别优雅降级一开始就构建完整功能，然后再根据低版本浏览器进行兼容。渐进增强针对低版本浏览器进行进行页面构建，保证最基本的功能，再对高级浏览器进行效果，交互等改进和追加功能达到更好的用户体验浏览器内核tridentIE,MaxThon，TT，The World，360，搜狗geckoFF,MozillaSuite/SeaMonkeywebkitSafariBlink（基于webkit）Chrome，Opera以前是presto内核，现改用Blink h5新特性 用于绘画的 canvas 元素 用于媒介回放的 video 和 audio 元素 对本地离线存储的更好的支持 新的特殊内容元素，比如 article、footer、header、nav、section 新的表单控件，比如 calendar、date、time、email、url、search 优点 网络标准统一、HTML5本身是由W3C推荐出来的。 多设备、跨平台 即时更新。 提高可用性和改进用户的友好体验； 有几个新的标签，这将有助于开发人员定义重要的内容； 可以给站点带来更多的多媒体元素(视频和音频)； 可以很好的替代Flash和Silverlight； 涉及到网站的抓取和索引的时候，对于SEO很友好； 被大量应用于移动应用程序和游戏。 缺点 安全：像之前Firefox4的web socket和透明代理的实现存在严重的安全问题，同时web storage、web socket 这样的功能很容易被黑客利用，来盗取用户的信息和资料。 完善性：许多特性各浏览器的支持程度也不一样。 技术门槛：HTML5简化开发者工作的同时代表了有许多新的属性和API需要开发者学习，像web worker、web socket、web storage 等新特性，后台甚至浏览器原理的知识，机遇的同时也是巨大的挑战 性能：某些平台上的引擎问题导致HTML5性能低下。 浏览器兼容性：最大缺点，IE9以下浏览器几乎全军覆没。 对HTML5认识?（是什么,为什么） 是什么： HTML5指的是包括 HTML 、 CSS 和 JavaScript 在内的一套技术组合。它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务（ Plug-in-Based Rich Internet Application ， RIA ），例如： AdobeFlash 、 Microsoft Silverlight 与 Oracle JavaFX 的需求，并且提供更多能有效加强网络应用的标准集。 HTML5 是 HTML 最新版本， 2014 年 10 月由万维网联盟（ W3C ）完成标准制定。目标是替换 1999 年所制定的 HTML 4.01 和 XHTML 1.0 标准，以期能在互联网应用迅速发展的时候，使网络标准达到匹配当代的网络需求。 为什么： HTML4陈旧不能满足日益发展的互联网需要，特别是移动互联网。为了增强浏览器功能 Flash 被广泛使用，但安全与稳定堪忧，不适合在移动端使用（耗电、触摸、不开放）。HTML5增强了浏览器的原生功能，符合 HTML5 规范的浏览器功能将更加强大，减少了 Web 应用对插件的依赖，让用户体验更好，让开发更加方便，另外 W3C 从推出 HTML4.0 到 5.0 之间共经历了 17 年， HTML 的变化很小，这并不符合一个好产品的演进规则。 对WEB标准以及W3C的理解与认识 标签闭合 标签小写 不乱嵌套 提高搜索机器人搜索几率 使用外链js和css脚本 结构行为表现的分离 文件下载与页面速度更快 内容能被更多的用户所访问 内容更广泛的设备所访问 行内，块级，空元素行内元素&lt;span&gt;，&lt;a&gt;，&lt;b&gt;，&lt;i&gt;，&lt;u&gt;，&lt;em&gt;，&lt;strong&gt;，&lt;label&gt;，&lt;input&gt; 块级元素&lt;div&gt;,&lt;h1&gt;-&lt;h6&gt;,&lt;ul&gt;,&lt;table&gt;,&lt;p&gt; 空元素&lt;br&gt; 替换元素替换元素是浏览器根据其标签的元素与属性来判断显示具体的内容。 比如：&lt;input /&gt; type=&quot;text&quot;的是，这是一个文本输入框，换一个其他的时候，浏览器显示就不一样 (X)HTML中的&lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt;都是替换元素，这些元素都没有实际的内容。 html语义化如标题（h1-h6），列表（li），强调（strong em）根据内容的结构化，选择合适的标签，便于开发者阅读，写出更优雅的代码的同时让浏览器的爬虫和机器更好的解析。 为什么语义化 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构 : 为了裸奔时好看 用户体验： 例如title、 alt 用于解释名词或解释图片信息、 label 标签的活用 有利于SEO： 和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化 语义化标签1234567&lt;header&gt;&lt;/header&gt;&lt;footer&gt;&lt;/footer&gt;&lt;nav&gt;&lt;/nav&gt;&lt;section&gt;&lt;/section&gt;&lt;article&gt;&lt;/article&gt; &lt;aslde&gt;&lt;/aside&gt;&lt;datalist&gt;&lt;/datalist&gt; 说说你对SVG理解SVG可缩放矢量图形（ Scalable Vector Graphics ）是基于可扩展标记语言（ XML ），用于描述二维矢量图形的一种图形格式。特点： 任意放缩用户可以任意缩放图像显示，而不会破坏图像的清晰度、细节等。 文本独立SVG图像中的文字独立于图像，文字保留可编辑和可搜寻的状态。也不会再有字体的限制，用户系统即使没有安装某一字体，也会看到和他们制作时完全相同的画面。 较小文件总体来讲，SVG文件比那些 GIF 和 JPEG 格式的文件要小很多，因而下载也很快。 超强显示效果SVG图像在屏幕上总是边缘清晰，它的清晰度适合任何屏幕分辨率和打印分辨率。 超级颜色控制SVG图像提供一个 1600 万种颜色的调色板，支持 ICC 颜色描述文件标准、 RGB 、线 X 填充、渐变和蒙版。 交互 X 和智能化。 SVG 面临的主要问题一个是如何和已经占有重要市场份额的矢量图形格式 Flash 竞争的问题，另一个问题就是 SVG 的本地运行环境下的厂家支持程度。浏览器支持：Internet Explorer9，火狐，谷歌 Chrome ， Opera 和 Safari 都支持 SVG 。IE8和早期版本都需要一个插件 - 如 Adobe SVG 浏览器，这是免费提供的。全局属性HTML 5 全局属性 属性 描述 accesskey 规定访问元素的键盘快捷键 class 规定元素的类名（用于规定样式表中的类）。 contenteditable 规定是否允许用户编辑内容。 contextmenu 规定元素的上下文菜单。 dir 规定元素中内容的文本方向。 draggable 规定是否允许用户拖动元素。 dropzone 规定当被拖动的项目/数据被拖放到元素中时会发生什么。 hidden 规定该元素是无关的。被隐藏的元素不会显示。 id 规定元素的唯一 ID。 lang 规定元素中内容的语言代码。 spellcheck 规定是否必须对元素进行拼写或语法检查。 style 规定元素的行内样式。 tabindex 规定元素的 tab 键控制次序。 title 规定有关元素的额外信息。 超链接target属性的取值和作用？target这个属性指定所链接的页面在浏览器窗口中的打开方式。 _blank 在新窗口中打开被链接文档。 _self 默认。在相同的框架中打开被链接文档。 _parent 在父框架集中打开被链接文档。 _top 在整个窗口中打开被链接文档。 framename 在指定的框架中打开被链接文档。data-属性的作用是什么？data-为前端开发者提供自定义的属性，这些属性集可以通过对象的 dataset 属性获取，不支持该属性的浏览器可以通过 getAttribute 12getAttribute(&apos;data-pic&apos;)dataset.pic 介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎(layout engineer或 Rendering Engine) 和 JS 引擎。渲染引擎：负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS引擎则：解析和执行 javascript 来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 iframe优点： 解决加载缓慢的第三方内容如图标和广告等的加载问题 Security sandbox 并行加载脚本 缺点： iframe会阻塞主页面的 Onload 事件； 搜索引擎的检索程序无法解读这种页面，不利于 SEO; 使用iframe之前需要考虑这两个缺点。如果需要使用 iframe ，最好是通过 javascript动态给iframe添加 src 属性值，这样可以绕开以上两个问题。Label的作用是什么，是怎么用的？label标签来定义表单控制间的关系 , 当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。&lt;label for=&quot;male&quot;&gt;male&lt;/label&gt;&lt;input type=&quot;radio&quot; id=&quot;male&quot;/&gt;title与h3的区别、b与strong的区别、i与em的区别？title属性没有明确意义只表示是个标题， H1 则表示层次明确的标题，对页面信息的抓取也有很大的影响；strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时： &lt;strong&gt; 会重读，而&lt;b&gt; 是展示强调内容。i内容展示为斜体， em 表示强调的文本；简述一下src与href的区别？src用于替换当前元素， href 用于在当前文档和引用资源之间确立联系。src是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本， img 图片和 frame 等元素。&lt;script src =&#39;js.js&#39;&gt;&lt;/script&gt;当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。href是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加&lt;link href=&#39;common.css&#39; rel=&#39;stylesheet&#39;/&gt;那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用@import方式。img的title和alt有什么区别？Alt 用于图片无法加载时显示 Title 为该属性提供信息，通常当鼠标滑动到元素上的时候显示谈谈你对canvas的理解？canvas是HTML5中新增一个HTML5标签与操作canvas的javascript API，它可以实现在网页中完成动态的2D与3D图像技术。标记和 SVG以及 VML 之间的一个重要的不同是，有一个基于 JavaScript 的绘图 API，而 SVG 和 VML 使用一个 XML 文档来描述绘图。SVG 绘图很容易编辑与生成，但功能明显要弱一些。 canvas可以完成动画、游戏、图表、图像处理等原来需要Flash完成的一些功能。HTML5标签的作用?(用途)a、使Web页面的内容更加有序和规范b、使搜索引擎更加容易按照HTML5规则识别出有效的内容c、使Web页面更接近于一种数据字段和表表单提交 通用提交按钮 &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; 自定义提交按钮 &lt;button type=&quot;Submit&quot;&gt;提交&lt;/button&gt; 图像按钮 &lt;input type=&quot;image&quot; src = &quot;btn.png&quot;&gt;csslink和@import的区别 1&lt;link rel=&apos;stylesheet&apos; rev=&apos;stylesheet&apos; href=&apos;CSS文件 &apos; type=&apos;text/css&apos; media=&apos;all&apos; /&gt; 123&lt;style type=&apos;text/css&apos; media=&apos;screen&apos;&gt;@import url(&apos;CSS文件 &apos;);&lt;/style&gt; link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。 link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。 link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。 link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。：nth-child(n)与：nth-of-type(n)的区别 使用p:nth-child(n)得满足两个条件 它的位置必须在它父元素的第n个，从1开始计数 它必须是P元素（相对于p:nth-child(n)来举例） 使用p:nth-of-type(n) 只要它是第n个P元素就行了 简述readyonly与disabled的区别 1、Readonly只针对input(text/password)和textarea有效，而disabled对于所有的表单元素有效，包括select,radio,checkbox,button等。 2、在表单元素使用了disabled后，我们将表单以POST或者GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去 盒子模型 Block Formatting Context(块级格式化上下文)如果一个元素符合了成为BFC的条件，那么该元素就成为一个隔离的容器，元素的内部元素会垂直的沿着父元素的边框排列，和外部元素互不影响。比如浮动元素会触发BFC，浮动元素的子元素主要受该浮动元素的影响，二两个浮动元素之间是互不影响的。 如何触发BFC1、float属性是除‘none’以外的其他值(left, right)2、overflow属性值是‘visible’以外的值(hidden, auto, scroll)3、position属性为absolute或者fixed4、display为以下值之一inline-block，table-cell，table-caption BFC的常见应用1、通过边缘不和浮动元素重叠的特性，实现两栏布局如果一个浮动元素后面跟着一个非浮动元素，那么就会产生一个覆盖的现象，通过触发BFC来清除覆盖，很多自适应的两栏布局就是这么做的。 2、清除元素内部浮动只要把父元素设为BFC就可以清除子元素的浮动了，同样因为IE6、7不支持BFC，因此需要设置zoom：1来触发hasLayout。 3、解决外边距叠加的问题在CSS当中，相邻的两个盒子（可能是兄弟，也可能是父子）的外边距可以叠加成一个单独的外边距。这种叠加外边距的方式叫折叠，因此所结合成的外边距叫做折叠外边距。 stacking context,布局规则z轴上的默认层叠顺序如下（从下到上）：根元素的边界和背景常规流中的元素按照html中顺序浮动块positioned元素按照html中出现顺序 如何创建stacking context：根元素z-index不为auto的定位元素a flex item with a z-index value other than ‘auto’opacity小于1的元素在移动端webkit和chrome22+，z-index为auto，position: fixed也将创建新的stacking context jsvar和function定义方法的区别在JS中有两种定义函数的方式， 是var aaa=function(){…} 函数表达式 是function aaa(){…} 函数声明 var foo3 = new Function(&#39;var temp = 100; this.temp = 200; return temp + this.temp;&#39;);var 方式定义的函数，不能先调用函数，后声明，只能先声明函数，然后调用。function方式定义函数可以先调用，后声明。请看代码：Js代码 12345678910111213&lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt; //aaa();这样调用就会出错 var aaa = function()&#123; alert(&quot;A&quot;); &#125; aaa();//这样就不会出错 //先调用后声明 bbb(); function bbb()&#123; alert(&quot;bb&quot;); &#125; &lt;/script&gt; DOMContentLoaded先触发DOMContentLoaded事件，后触发load事件。 DOM文档加载的步骤为 解析HTML结构。 加载外部脚本和样式表文件。 解析并执行脚本代码。 DOM树构建完成。//DOMContentLoaded 加载图片等外部文件。 页面加载完毕。//load DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系 e.getAttribute()，是标准DOM操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性 e.propName通常是在HTML文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如a标签生成HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用getAttribute进行访问 e.getAttribute()返回值是源文件中设置的值，类型是字符串或者null（有的实现返回””） e.propName返回值可能是字符串、布尔值、对象、undefined等 大部分attribute与property是一一对应关系，修改其中一个会影响另一个，如id，title等属性 一些布尔属性的检测设置需要hasAttribute和removeAttribute来完成，或者设置对应property 像&lt;a href=&quot;../index.html&quot;&gt;link&lt;/a&gt;中href属性，转换成property的时候需要通过转换得到完整URL 一些attribute和property不是一一对应如：form控件中对应的是defaultValue，修改或设置value property修改的是控件当前值，setAttribute修改value属性不会改变value property 对象到字符串的转换步骤 如果对象有toString()方法，javascript调用它。如果返回一个原始值（primitive value如：string number boolean）,将这个值转换为字符串作为结果 如果对象没有toString()方法或者返回值不是原始值，javascript寻找对象的valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果 否则，javascript不能从toString()或者valueOf()获得一个原始值，此时throws a TypeError 对象到数字的转换步骤 如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果 否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果 否则，throws a TypeError网络相关cookies，sessionStorage 和 localStorage 的区别?cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie 存储大小： cookie数据大小不能超过4k。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间：localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除。cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 seessionStorage会话级别的存储临时性的，页面打开有，页面关闭没有数据不共享通过a标签来跳出一个页面，则sessionStorage共享 localStorage持久化的本地存储永久性的存储 不能跨域数据共享 cookiecookie在同源且符合path规则的文档之间共享max-age用秒来设置cookie的生存期。如果max-age为0，则表示删除该cookie。如果max-age为负数，则表示该cookie仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该cookie即失效。 如何实现浏览器内多个标签页之间的通信?WebSocket、 SharedWorker ；postMessage也可以调用localstorge、 cookies 等本地存储方式；localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信；注意quirks： Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常； get和post的区别 http报文 起始行： HTTP/1.0 200 OK 首部：Content-type:text/plainContent-length:19 主体：HI IM A MESSAGE http方法GET： 请求指定的页面信息，并返回实体主体。HEAD： 只从服务器获取文档的的首部。POST： 向服务器发送需要处理的数据PUT： 将请求的主体部分存储在服务器上DELETE： 请求服务器删除指定的页面。OPTIONS： 允许客户端查看服务器的性能。TRACE：对可能经过代理服务器传送到服务器上去的报文进行追踪 状态码① 客户方错误100 继续101 交换协议② 成功200 OK201 已创建202 接收203 非认证信息204 无内容205 重置内容206 部分内容③ 重定向300 多路选择301 永久转移302 暂时转移303 参见其它304 未修改（Not Modified）305 使用代理④ 客户方错误400 错误请求（Bad Request）401 未认证402 需要付费403 禁止（Forbidden）404 未找到（Not Found）405 方法不允许406 不接受407 需要代理认证408 请求超时409 冲突410 失败411 需要长度412 条件失败413 请求实体太大414 请求URI太长415 不支持媒体类型⑤ 服务器错误500 服务器内部错误501 未实现（Not Implemented）502 网关失败504 网关超时505 HTTP版本不支持 css和js引入位置 浏览器解析html页面首先浏览器先下载html，然后在内存中把html代码转化成Dom Tree，然后浏览器根据Dom Tree上的Node分析css和Images，当文档下载遇到js时，js独立下载。 js是阻塞加载，会影响页面加载的速度，如果js文件比较大，算法也比较复杂的话，影响更大。CSS放在前端是页面渲染时首先是根据DOM结构生成一个DOM树然后加上CSS样式生成一个渲染树，如果CSS放在后面可能页面会出现闪跳的感觉，或者是白屏或者布局混乱样式很丑直到CSS加载完成。 js异步加载 动态创建dom 12345678&lt;script&gt;(function(d,s,id)&#123; var js,fjs = d.getElementByTagName(s)[0]; if(d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = &quot;//connect.facebook.net/en_US/all.js#xfbml=1&quot;; fjs.parentNode.insertBefore(js,fjs);&#125;(document,&apos;script&apos;,&apos;facebook-jssdk&apos;));&lt;/script&gt; async和defer属性defer是严格顺序加载，async是哪个先加载完加载哪个 通过Ajax获取脚本内容，然后再创建 懒加载 第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟. 第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。 第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。 图片的延迟加载在页面的load没有触发之前，把所有的指定id的元素内的img放入到imgs中，将所有的图片的src值放入到一个新建的_src属性中，把src设置为指定的显示图片。然后，在document.body的scroll事件触发时，循环计算imgs中的img元素位置是否正好在浏览器显示框范围内，如果是，则将img元素的_src属性的值赋给src，这样图片就能显示出来。 预加载 用CSS和JavaScript实现预加载:backgrond 仅使用JavaScript实现预加载 使用Ajax实现预加载 WebSocket与消息推送？HTTP协议决定了服务器与客户端之间的连接方式，无法直接实现消息推送（ F5 已坏） , 一些变相的解决办法：双向通信与消息推送 短轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。优点：后端程序编写比较容易。缺点：请求中有大半是无用，浪费带宽和服务器资源。实例：适于小型应用。 长轮询：客户端向服务器发送Ajax请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。优点：在无消息的情况下不会频繁的请求，耗费资小。缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet 异步的 ashx ，实例：WebQQ、 Hi 网页版、 Facebook IM 。 长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求或是采用 xhr 请求，服务器端就能源源不断地往客户端输入数据。优点：消息即时到达，不发无用请求；管理起来也相对便。缺点：服务器维护一个长连接会增加开销。实例：Gmail聊天 Flash Socket：在页面中内嵌入一个使用了 Socket 类的 Flash 程序 JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信， JavaScript 在收到服务器端传送的信息后控制页面的显示。优点：实现真正的即时通信，而不是伪即时。缺点：客户端必须安装Flash插件；非 HTTP 协议，无法自动穿越防火墙。实例：网络互动游戏。 Websocket:WebSocket是 HTML5 开始提供的一种浏览器与服务器间进行全双工(双向同时通信)通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。特点:a、事件驱动error，message，close，openb、异步c、使用 ws 或者 wss 协议的客户端 socketd、能够实现真正意义上的推送功能缺点：少部分浏览器不支持，浏览器支持的程度与方式有区别 长连接短连接 长连接: 指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接; 一般需要自己做在线维持。 短连接: 指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接;一般银行都使用短连接。它的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段 通常的短连接操作步骤是： 连接→数据传输→关闭连接； 而长连接通常就是： 连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接； 跨域 同源：两个文档同源需满足 协议相同 域名相同 端口相同 跨域通信：js进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法 如果是log之类的简单单项通信，新建&lt;img&gt;,&lt;script&gt;,&lt;link&gt;,&lt;iframe&gt;元素，通过src，href属性设置为目标url。实现跨域请求 如果请求json数据，使用&lt;script&gt;进行jsonp请求 现代浏览器中多窗口通信使用HTML5规范的targetWindow.postMessage(data, origin);其中data是需要发送的对象，origin是目标窗口的origin。window.addEventListener(‘message’, handler, false);handler的event.data是postMessage发送来的数据，event.origin是发送窗口的origin，event.source是发送消息的窗口引用 内部服务器代理请求跨域url，然后返回数据 跨域请求数据，现代浏览器可使用HTML5规范的CORS功能，只要目标服务器返回HTTP头部Access-Control-Allow-Origin: *即可像普通ajax一样访问跨域资源 缓存应用程序缓存是 HTML5 的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML 、 CSS 、图片以及JavaScript 。这个特性可以提高网站性能，它的实现借助于 manifest 文件，如下： 1234&lt;!doctype html&gt;&lt;html manifest=”example.appcache”&gt;…..&lt;/html&gt; 123456//CACHE MANIFEST第一行，CACHE MANIFEST，是必需的：CACHE MANIFEST/theme.css/logo.gif/main.js 与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例) 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析如下： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面） http缓存缓存规则解析强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。 判断是否失效ExpiresExpires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP 1.1 的版本，使用Cache-Control替代。 Cache-ControlCache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。 private: 客户端可以缓存 public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的） max-age=xxx: 缓存的内容将在 xxx 秒后失效 no-cache: 需要使用对比缓存来验证缓存数据（后面介绍） no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so…基本上和它说886） http2.0新特性原文 增加二进制分帧HTTP 2.0在应用层跟传送层之间增加了一个二进制分帧层，从而能够达到在不改动HTTP的语义，HTTP方法，状态码，URI以及首部字段的情况下，突破HTTP 1.1的性能限制，改进传输性能，实现低延迟和高吞吐量 压缩头部HTTP 2.0在客户端和服务端使用首部表来跟踪和存储之间发送的键-值对，对相同请求而言不需要再次发送请求和相应发送，通信期间几乎不会改变的通用键值,如user-Agent和content-Type值发送一次，相当于做了一层缓存。 如果请求不包含首部，如：对同一资源的轮询请求，那首部开销为零字节 如果首部发生变化，那只需发送变化的数据在Headers帧里面，新增或修改的首部帧会被追加到首部表 多路复用对HTTP 1.1而言，浏览器通常有并行连接的限制，即最多几个并行链接。而多路复用允许通过单一的HTTP 2.0连接发起多重的请求-相应消息这意味着HTTP 2.0的通信都在一个连接上完成了，这个连接可以承载任意数量的双向数据流，直观来说，就是上面我们所做的优化已经不需要了。请求优先级所有资源可以并行交错发送， 那想要优先拿到CSS和JS而不是图片怎么办，在每个HTTP 2.0的流里面有个优先值，这个优先值确定着客户端跟服务器处理不同的流采取不同的优先级策略，高优先级优先发送，但这不是绝对的(绝对等待会导致首队阻塞问题)服务器提示HTTP 2.0新增加服务器提示，可以先于客户端检测到将要请求的资源，提前通知客户端，服务器不发送所有资源的实体，只发送资源的URL，客户端接到提示后会进行验证缓存，如果真需要这些资源，则正式发起请求（服务器主动更新静态资源）服务器可以对一个客户端请求发送多个响应。换句话说，服务器除了对最初请求的响应外，还可以额外向客户端推送资源，而无需客户端明确地请求性能优化 你有哪些性能优化的方法？ （1）、减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。合理设置 HTTP缓存（2）、前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数（3）、用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。（4）、当需要设置的样式很多时设置className而不是直接操作style。（5）、少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。（6）、避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。（7）、图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 操作系统死锁:定义如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁 资源死锁的条件 互斥:每个资源要么已经分配给一个进程，要么没有 占有和等待条件:已经得到某个资源的进程可以再请求新的资源 不可抢占条件:已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式的释放 环路等待条件:死锁发生时，系统中一定有由两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程时所占有的资源安全序列，银行家算法 死锁预防: 破坏互斥条件 破坏占有和等待:资源预先分配，所有的进程在开始前请求所需的全部资源，如果全部资源可用。那么就将它们分配给这个进程，于是该进程肯定能够运行结束。如果有一个或者多个资源正被使用，那么不进行分配，进程等待 破坏不可抢占条件: 破坏环路等待条件:资源统一编号 解决死锁的方法： 不管 管： 不允许发生{ 静态：事先预防 动态：过程中避免} 管不了，还是发生-》检测-》解除进程定义： 进程是程序作用在一组数据上的一次执行过程（一次计算） 进程是操作系统中一个可独立调度和资源分配的基本单位 进程是可以和别的计算并发执行的计算 创建进程4种方法 系统初始化 执行了正在执行的进程所调用的进程创建系统调用 用户请求创建一个新进程 一个批处理作业的初始化 线程线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 进程和线程的联系 同一个进程中的多个线程之间可以并发执行. 一个程序至少有一个进程,一个进程至少有一个线程. 线程的划分尺度小于进程，使得多线程程序的并发性高。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 进程间通信 共享内存 消息机制：消息队列，信箱 管道 管道：是一种半双工的通信方式,数据只能单向流动,而且只能在具有亲缘关系的进程间使用.进程的亲缘关系一般指的是父子关系.管道一般用于两个不同进程之间的通信.当一个进程创建了一个管道,并调用fork创建自己的一个子进程后,父进程关闭读管道端,子进程关闭写管道端,这样提供了两个进程之间数据流动的一种方式. 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。 信号量：是一个计数器,可以用来控制多个线程对共享资源的访问.,它不是用于交换大批数据,而用于多线程之间的同步.它常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源.因此,主要作为进程间以及同一个进程内不同线程之间的同步手段. cpu调度 选择内存上的处于就绪状态的进程，并分配CPU给它们使用（依照算法）。通过多道程序设计可以尽可能高的提高CPU利用率，但道数不可能无限增加。 同时： 宏观－程序进入内存，被操作系统调度； 微观－进程正在CPU上运行(Running) 调度：切换的过程中，切换越多，系统消耗越多，故道数不可能无限增加（另外还有内存方面的考虑） 调度准则(Scheduling Criteria) CPU利用率(CPU utilization) 吞吐量(Throughout)：单位时间内执行作业的数量。 周转时间(Turnaround time)：提交完毕-&gt;执行结束所需时间。 等待时间(Waiting time)：在就绪队列内等待的时间，多次等待时间做和。 响应时间(Response time)：提交完成-&gt;首次给出相应所需时间。 调度算法(Scheduling Algorithms) First-Come,First-Served(FCFS)：先来先服务的调度原则 Shortest-Job-First(SJF) Scheduling：短作业优先调度原则 Priority Scheduling：优先级调度原则 Round-Robin Scheduling：时间块调度原则 Multilevel Queue Scheduling：多级队列调度原则 Multilevel Feedback Queue：多级反馈队列调度原则 工具webpack作用WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 优点模块化在webpack看来一切都是模块！这就是它不可不说的优点，包括你的JavaScript代码，也包括CSS和fonts以及图片等等等，只有通过合适的loaders，它们都可以被当做模块被处理。CSS csswebpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。 css modulesCSS modules 的技术就意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack从一开始就对CSS模块化提供了支持，在CSS loader中进行配置后，你所需要做的一切就是把”modules“传递都所需要的地方，然后就可以直接把CSS的类名传递到组件的代码中，且这样做只对当前组件有效，不必担心在不同的模块中具有相同的类名可能会造成的问题。 CSS预编译 webpack-pulgins 热更新]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js和css载入]]></title>
      <url>%2F2017%2F04%2F24%2Fjs%E5%92%8Ccss%E8%BD%BD%E5%85%A5%2F</url>
      <content type="text"><![CDATA[js异步加载 动态创建dom 12345678&lt;script&gt;(function(d,s,id)&#123; var js,fjs = d.getElementByTagName(s)[0]; if(d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = &quot;//connect.facebook.net/en_US/all.js#xfbml=1&quot;; fjs.parentNode.insertBefore(js,fjs);&#125;(document,&apos;script&apos;,&apos;facebook-jssdk&apos;));&lt;/script&gt; async和defer属性defer是严格顺序加载，async是哪个先加载完加载哪个 通过Ajax获取脚本内容，然后再创建元素，并设置元素的text，再将元素添加进DOM中 Promise也是 懒加载 第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟. 第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。 第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。 预加载 用CSS和JavaScript实现预加载:backgrond 仅使用JavaScript实现预加载 使用Ajax实现预加载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[将字符串转换成数字]]></title>
      <url>%2F2017%2F04%2F24%2F%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E5%AD%97%2F</url>
      <content type="text"><![CDATA[parseInt（）字符串第一个字符是数字，直到碰到小数点或者其他字符 12var a = parseInt(&apos;10.36aa&apos;)//10var a=parseInt(&apos;.10.36aa&apos;)//NaN parseFloat()如果第一个字符是小数点，则以0.开头直到遇到第二个小数点或者其他字符 123var a = parseFloat(&apos;.36.33aa&apos;)//0.36var a = parseFloat(&apos;10.36.33aa&apos;)//10.36var a = parseFloat(&apos;a.36.33aa&apos;)//NaN + 1234var a = +&apos;a.36.33aa&apos;//NaNvar a = +&apos;.36.33aa&apos;//NaNvar a = +&apos;0.36.33&apos;//NaNvar a = +&apos;0.36&apos;//0.36 Number()强制转换1234var a = Number(&apos;.36&apos;)//0.36var a = +&apos;a.36.33aa&apos;//NaNvar a = +&apos;.36.33aa&apos;//NaNvar a = +&apos;0.36.33&apos;//NaN]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[node.js之学习]]></title>
      <url>%2F2017%2F04%2F21%2Fnode-js%E4%B9%8B%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[创建第一个应用123456789var http = require(&apos;http&apos;)http.createServer(function(req,res) &#123; //发送http头部 //状态码200 //内容类型：text/plain res.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/plain&apos;&#125;); //发送响应信息 res.end(&apos;hello world&apos;)&#125;).listen(8080) 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。 接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。repl(交互式解释器)ctrl + c - 退出当前终端。ctrl + c 按下两次 - 退出 Node REPL。ctrl + d - 退出 Node REPL.向上/向下 键 - 查看输入的历史命令tab 键 - 列出当前命令.help - 列出使用命令.break - 退出多行表达式.clear - 退出多行表达式.save filename - 保存当前的 Node REPL 会话到指定文件.load filename - 载入当前 Node REPL 会话的文件内容。 回调函数不阻塞： 12345var fs = require(&apos;fs&apos;);var data = fs.readFile(&apos;ball.html&apos;,function(err,data) &#123; console.log(data.toString());&#125;)console.log(&apos;success&apos;) 阻塞： 123var anoData = fs.readFileSync(&apos;cors.html&apos;)console.log(anoData.toString())console.log(&apos;success&apos;) 事件循环Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。 12345678910111213141516171819202122232425262728293031var EventEmitter = require(&apos;events&apos;).EventEmitter;var life = new EventEmitter();life.setMaxListeners(5)//某个事件名出现的最多次数life.on(&apos;dis&apos;,function() &#123; console.log(&apos;dis&apos;)&#125;)life.on(&apos;dis&apos;,function() &#123; console.log(&apos;dis&apos;)&#125;)life.on(&apos;dis&apos;,function() &#123; console.log(&apos;dis&apos;)&#125;)life.on(&apos;dis&apos;,function() &#123; console.log(&apos;dis&apos;)&#125;)life.on(&apos;ddd&apos;,water)life.on(&apos;ddd&apos;,function()&#123; console.log(&apos;ddd2&apos;)&#125;)function water()&#123; console.log(&apos;ddd&apos;)&#125;//life.removeListener(&apos;ddd&apos;,water)//移除事件//life.removeAllListeners()var ddd = life.emit(&apos;ddd&apos;)var ss = life.emit(&apos;ss&apos;)console.log(dis)console.log(ddd)console.log(ss)console.log(life.listeners(&apos;dis&apos;).length)//某个事件的个数console.log(EventEmitter.listenerCount(life,&apos;dis&apos;))//某个事件的个数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cors]]></title>
      <url>%2F2017%2F04%2F20%2Fcors%2F</url>
      <content type="text"><![CDATA[原文 跨域资源共享（cross-origin resource sharing 注：CORS需要浏览 器和服务器同时支持。目前所有浏览器都支持，IE不能低于IE浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 简单请求与非简单请求只要同时满足以下两大条件，就属于简单请求 请求方法是以下三种方法之一： HEAD GET POST HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 对于简单请求，浏览器直接发出CORS请求。就是在头信息中，增加一个Origin字段。用来说明本次请求来自哪个源。服务器再根据这个值，决定是否同意这个请求。如果指定的源不在许可范围内，服务器会返回一个正常的http回应。这个回应的头信息没有包含Access-Control-Allow-Origin字段（祥见下文），从而抛出一个错误，error事件监听，但是这个响应的状态码可能是200 Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 withCredentials 属性如果要把Cookie发到服务器，一方面要服务器同意，制定Access-Control-Allow-Credentials字段 Access-Control-Allow-Credentials: true另一方面还要在ajax请求中打开withCredentials属性。12var xhr = new XMLHttpRequest();xhr.withCredentials = true;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css兼容]]></title>
      <url>%2F2017%2F04%2F10%2Fcss%E5%85%BC%E5%AE%B9%2F</url>
      <content type="text"><![CDATA[Trident内核：前缀为-ms Gecko内核：前缀为-moz Presto内核：前缀为-o Webkit内核：前缀为-webkit 123456.box &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;&#125; IE5-8不支持opacity，解决办法： 12345.opacity &#123; opacity: 0.4 filter: alpha(opacity=60); /* for IE5-7 */ -ms-filter: &quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=60)&quot;; /* for IE 8*/&#125; IE6不支持min-height，解决办法使用css hack 12345.box&#123; min-height:600px; height:auto !important; height:600px;&#125; ol内li的序号全为1，不递增。解决方法：为li设置样式display: list-item; 由于innerText并非W3C标准属性，因此我们无法在FireFox中使用它(修正：FF45+已经支持innerText属性)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闭包应用场景]]></title>
      <url>%2F2017%2F04%2F09%2F%E9%97%AD%E5%8C%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
      <content type="text"><![CDATA[闭包是指有权访问另一个函数作用域的变量的函数 setTimeout setTimeout(func,time)这里的func不能带参数,解决这个问题需要用闭包 1234567function func(param) &#123; return function() &#123; alert(param); &#125;&#125;var f = func(1)setTimeout(f, 1000); 代替全局变量 123456789101112131415//闭包，test2是局部变量，这是闭包的目的//我们经常在小范围使用全局变量，这个时候就可以使用闭包来代替。(function()&#123;var test2=222;function outer()&#123; alert(test2);&#125;function test()&#123; alert(&quot;测试闭包：&quot;+test2);&#125;outer(); //222test(); //测试闭包：222&#125;)(); alert(test2); //未定义，这里就访问不到test2 为节点循环绑定click事件，在事件函数中使用当次循环的值或节点，而不是最后一次循环的值或节点 创建特权方法用于访问控制]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[内存泄漏]]></title>
      <url>%2F2017%2F04%2F09%2F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
      <content type="text"><![CDATA[setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包 123456789101112131415function assignHandler()&#123; var element = document.getElementById(&quot;someElement&quot;); element.onclick = function()&#123; alert(element.id); &#125;;&#125;应改为function assignHandler()&#123; var element = document.getElementById(&quot;someElement&quot;); var id = element.id; element.onclick = function()&#123; alert(id); &#125;; element = null;&#125; 控制台日志 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git学习]]></title>
      <url>%2F2017%2F04%2F08%2Fgit%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[简介 Git是目前世界上最先进的 分布式版本控制系统 CVS及SVN都是 集中式的版本控制系统集中式版本控制系统：有一个中央服务器，先取再传分布式版本控制系统：没有中央服务器，每个人的电脑上都有一个版本库，故不需要联网，多人写作，推送修改。具有强大的分支管理功能安装先下载，然后 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 创建版本库（repository）1234567$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit$ git init$ git add 文件名$ git commit -m &quot;....xxxx&quot; 时光机$ git status 查看仓库的状态$ git diff 文件名 查看difference 版本回退用 $ git log 来查看历史记录$ git log --pretty=oneline 只查看一行上一个版本 head^ 上上个 head^^$ git reset --hard HEAD^$ git reset --hard 3628164 这里的数字是id$ git reflog 记录每一个记录，可以找到id 工作区和暂存区工作区就是电脑里文件目录版本库：.git文件，版本库里最重要的stage就是暂存区第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 管理修改cat index.html 查看index.html的内容如果：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit第二次修改并没有进入暂存区，不会被提交解决： git add再git commit 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 撤销修改$ git checkout -- readme.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 把readme.txt文件在工作区的修改全部撤销 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 删除修改123$ git rm test.txtrm &apos;test.txt&apos;$ git commit -m &quot;remove test.txt&quot; 如果删错了$ git checkout -- test.txt 添加到远程库关联 git remote add origin git@server-name:path/repo-name.git第一次推送 git push -u origin master从远程库克隆 $ git clone git@github.com:michaelliao/gitskills.git 分支 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 用git log –graph命令可以看到分支合并图。 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 多人协作多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[剖析异步]]></title>
      <url>%2F2017%2F04%2F07%2F%E5%89%96%E6%9E%90%E5%BC%82%E6%AD%A5%2F</url>
      <content type="text"><![CDATA[先看一段代码 123456789function f2() &#123; console.log(2)&#125;function f1(callback)&#123; callback() console.log(1)&#125;f1(f2)//2 1 3 123456789function f2() &#123; console.log(2)&#125;function f1(callback)&#123; setTimeout(callback,0) console.log(1)&#125;f1(f2)//1 3 2 上面代码有何区别呢，第一段代码f1函数返回之前callback会被立即执行第二段代码则是f1函数返回之后要等任务完成之后才调用callback。这里的setTimeout将callback加入任务队列 跟java中的异步和同步代码会交叉输出相比，js中的异步其实是排好队输出的。由于js是单线程执行代码的，所以没有那种交叉输出的效果。 setTimeout的回调的执行顺序不仅与代码顺序有关还和延迟时间有关。 123f1();f2();f3(); 如果f1中执行了大量的耗时操作，而且f2需要在f1之后执行。则程序可以改为回调的形式。如下： 12345678910111213141516171819function f1(callback)&#123; setTimeout(function () &#123; // f1的大量耗时任务代码并的到三个结果i,l,you. console.log(&quot;this is function1&quot;); var i = &quot;i&quot;, l = &quot;love&quot;, y = &quot;you&quot;; if (callback &amp;&amp; typeof(callback) === &quot;function&quot;) &#123; callback(i,l,y); &#125; &#125;, 50);&#125;function f2(a, b, c) &#123; alert(a + &quot; &quot; + b + &quot; &quot; + c); console.log(&quot;this is function2&quot;);&#125;function f3()&#123;console.log(&quot;this is function3&quot;);&#125;f1(f2);f3(); 运行结果： 1234this is function3this is function1i love youthis is function2 采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。回调函数的优点是简单，轻量级（不需要额外的库）。缺点是各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。某个操作需要经过多个非阻塞的IO操作，每一个结果都是通过回调，产生意大利面条式（spaghetti）的代码。 Promises的本质实际就是通过状态机来实现的 12345678910setTimeout(()=&gt;console.log(4),0)var p1=new Promise(function(resolve,reject)&#123; setTimeout(()=&gt; console.log(3),0) resolve(&apos;hello&apos;)&#125;).then(function(val)&#123; console.log(val)&#125;)setTimeout(()=&gt; console.log(2),0)console.log(5)//5 hello 4 3 2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[框架对比]]></title>
      <url>%2F2017%2F04%2F04%2F%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94%2F</url>
      <content type="text"><![CDATA[vue.js 最低支持到ie9 vue.js是一个渐进式框架，自底向上增量开发 任意应用界面都可以抽象成组件树 vue在背后做了很多工作，数据和dom是绑定的，一切都是响应的 vue把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。 变化检测：Vue 会在初始化实例时对属性执行 getter/setter 转化过程 Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。 父子组件的关系可以总结为 props down, events up vue和react相似之处： 使用virtual dom深度剖析virtual dom 提供了响应式和组件化的视图组件 将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。分歧： vue在dom操作上尽可能少的添加额外性能的开销 vue的组件会在渲染过程中自动追踪 html&amp;css在react中都是由JavaScript来写的，所有的组件渲染依靠jsx。优势：可以用完全用JavaScript来构造视图。而vue是拥抱html和css的 vue使用scoped来实现单文件组件css,react使用css models vue和angular1 vue的api设计更加简单 vue使用webpack template模块化，更灵活 angular1用的是双向绑定，而vue在不同组件中强制单向数据流 vue中指令和组件分的很清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 有自己的视图和数据逻辑。 在angular1中随着watcher越来越多，会导致变慢，并且如果一个watcher触发另一个更新，脏检查会执行多次。而vue是基于依赖追踪的观察系统而且异步更新队列 angular2 面向大型企业应用 typescript]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[想说]]></title>
      <url>%2F2017%2F04%2F03%2Fdaily1%2F</url>
      <content type="text"><![CDATA[折腾hexo两天了，让我对那些牛逼的人又心生崇拜了然而还有些功能没加，又丑又慢，下面进入正题 3月结束了，过得好累啊3月，但4月会更累。。。学校里的樱花都开了，浪多berber嬢嬢些都在照相。一同学都和女朋友跑武大去看樱花咯。而我们。。。前面那女生还是同学的朋友来坐一下。活得不累，活的gay啊！3月中旬投了一个成都的小公司，结果被面得我毫无自信了。然后就看面经，看计网，看数据结构，可是还是好差。。。网申了几家公司，但笔试好坑好坑，估计一家都不得给面试。（怀疑人生中） 但我觉得现在得生活好充实，忙碌吧但又自由，最主要是有几个志同道合的同学，生活还是比高三那会舒服。不知不觉还是快要高考了，又想到那个不知天高地厚的自己，觉得最差也要考个川大，结果啪啪啪打脸了吧但现在觉得还是不咋个。当初也不造咋选了计算机，可能觉得高大上吧。结果进学校就被c语言弄的怀疑人生。感觉什么都不懂更懵逼的是当时一个班学长说来辅导我们高数啊什么的，他说我们有问题就去二教五楼找他，他随时在那儿。当时我就觉得，握草，这学长这么牛批，换我怎么也做不到，都不打游戏吗，结果我现在就是他那样了?我就是因为刚开始太闲了，要不就是睡觉，最后无奈玩上了游戏，一玩就不得了了，沉浸于自我无法自拔，比照镜子还有成就感。但我觉得那会游戏维持了我跟高中兄弟的联系，大学同学也赞同我说法。现在不玩了，兄弟就都在心中了，因为大家都开始忙了，等回家了再一醉方休。讲真好久没有跟熟识的人聊天了。不知道他们过得咋样呢。不过我晓得他们背单词牛批的很，100多天的打卡。我这学期刚开始也在打，结果最多一周。和寝室考研的兄弟伙些一样，他们也只坚持了1周的早起。 有点困咯，晕乎乎你以为要结束了，no 今天是我爸的生日 不对是昨天，3号生日快乐啊爸爸，好久没陪爸爸过生日了。惭愧至极。我也不造为什么我本来能说个不停的人，在家人面前就始终说不出来，从小到大都这样，是不是要看哈心里医生啊。好久没有和爸爸合照了，突然好想家人啊。这学期过了我要常回家了，感觉家乡的人都觉得我消失了一样。每次三姑六婆都在说自己孩子怎么的时候，我想爸妈一定会有失落吧，“俊杰总不喜欢和我们分享自己的事”。但是我也不是不喜欢，怎么说呢，从小到大都是这样，已经习惯了，难过的事不会告诉他们，高兴的事也偶尔告诉他们。我真的，不管今后再外面闯的什么个层次，我心里永远都觉得自己是失败的。我做的不好，我也不知道怎么做好。照片是08年的时候吧好像，我妈弄在微信里发给我的，那时候笑的好灿烂，但这分钟我哭了。。 我爱你们愿望 家人平安健康]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[居中]]></title>
      <url>%2F2017%2F03%2F07%2F%E5%B1%85%E4%B8%AD%2F</url>
      <content type="text"><![CDATA[方法一：运用flex布局 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .app&#123;width: 500px;height: 500px;background: green;&#125; .app&#123;display: flex;align-items: center;justify-content: center&#125; /*这样用text-align无用，布局以后，子元素的float、clear和vertical-align属性将失效。*/ .app img&#123;width: 200px;height: 200px&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class='app'&gt; &lt;img src="img/bg.jpg" alt="img" title="img"/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方法二：也是运用flex布局，不过这次是在子元素用align-self：center 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .app&#123;width: 500px;height: 500px;background: green;&#125; .app&#123;display: flex;justify-content: center&#125; .app img&#123;align-self: center&#125; .app img&#123;width: 200px;height: 200px&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class='app'&gt; &lt;img src="img/bg.jpg" alt="img" title="img"/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方法一和方法二的效果如图：方法三：如果在一段块元素包裹的行内元素中有某个元素比较特殊, 比如: 大写加粗的文字 、 乱入的图片图标, 垂直居中: 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .text&#123;width: 500px;height: 500px;background: red;&#125; .text img&#123; width: 200px;height: 200px;vertical-align: middle;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="text"&gt; &lt;img src="img/bg.jpg" alt="img" title="img"/&gt;可以的 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果： 方法四：父元素相对定位(或其他定位){ position: relative; }子元素绝对定位{ position: absolute; top: 0; left: 0; bottom: 0; right: 0; margin: auto }1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .outer&#123;width: 400px;height: 400px;background: pink;position: relative;&#125; .inner&#123;width: 200px;height: 200px;background: black;position: absolute;left: 0;bottom: 0;top: 0;right: 0;margin: auto&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="outer"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果：方法五：用padding方法六：height/line-height设为相同值方法七：父元素设置{ display: table-cell; vertical-align: middle; } 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .app&#123;width: 500px;height: 500px;background: green;&#125; .app&#123;display: table-cell;vertical-align: middle;text-align: center&#125; .app img&#123;width: 200px;height: 200px&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class='app'&gt; &lt;img src="img/bg.jpg" alt="img" title="img"/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果：方法八：父元素：position：relative中间元素：position：absolute；left：50%；top：50%子元素：position：absolute；left：-50%；top：-50% 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .container&#123;width: 400px;height: 400px;position: relative;background: pink&#125; .box&#123;position: absolute;left:50%;top:50%;width: 200px;height: 200px&#125; .boxinner&#123;width: 200px;height: 200px;position: relative;left: -50%;top:-50%;background: black&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="box"&gt; &lt;div class="boxinner"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果：方法九：父元素：position：relative子元素：position：absolute；（transform: translate: (-50%, 50%) ）或者（margin-left：-xxpx；margin-top：-xxpx）top：50%；left：50%1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .outer&#123;width: 400px;height: 400px;background: pink;position: relative;&#125; .inner&#123;width: 200px;height: 200px;position: absolute;margin-left: -100px;margin-top: -100px;left: 50%;top: 50%;background: black&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="outer"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果：方法十利用伪元素 1234567.main&#123;width: 400px;height: 400px;background: green;text-align: center&#125;.main:after&#123;content: '';display: inline-block;width: 0;height: 100%;vertical-align: middle;overflow: hidden;&#125;.inner&#123;width: 100px;height: 100px;background: pink;vertical-align: middle;display: inline-block;&#125;&lt;div class="main"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt; 方案十一： 1234567多行文本居中&lt;div style="width:150px;height:100px;line-height:100px;background-color:#ccc;font-size:0;"&gt; &lt;span style="display:inline-block;font-size:10px;line-height:1.4em;vertical-align:middle;"&gt;This is a test.&lt;br/&gt; This is a test. &lt;/span&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面经学习]]></title>
      <url>%2F2017%2F03%2F07%2F%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[url回车后发生了什么域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？（1）行内元素有：a b span img input select strong（强调的语气）（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p（3）常见的空元素：12&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 鲜为人知的是： 12&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 页面可见性（Page Visibility API） 可以有哪些用途？通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放； 权重计算规则第一等：代表内联样式，如: style=””，权值为1000。第二等：代表ID选择器，如：#content，权值为0100。第三等：代表类，伪类和属性选择器，如.content，权值为0010。第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。继承的样式没有权值。 多列等高align-item:stretch12345678.container&#123;margin: 0 auto;width: 600x;border: 3px solid #00c;overflow: hidden;&#125;.left&#123;float: left;width: 150px;background: #b0b0b0;padding-bottom: 100px;margin-bottom: -100px;&#125;.right&#123;float: left;width: 450px;background: #6cc;padding-bottom: 100px;margin-bottom: -100px;&#125;&lt;div class="container"&gt; &lt;div class="left"&gt;ssss&lt;/div&gt; &lt;div class="right"&gt;ssss&lt;br&gt;&lt;br/&gt;&lt;br/&gt;dfdkjij&lt;/div&gt;&lt;/div&gt; li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。 123456789101112&lt;style type="text/css"&gt; ul&#123;list-style-type: none;font-size: 0;padding: 0;margin: 0&#125; li&#123;width: 50px;height: 50px;background: red;display: inline-block;font-size: 12px;vertical-align: top&#125; &lt;ul&gt; &lt;li&gt;sss&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;dd&lt;/li&gt; &lt;li&gt;gg&lt;/li&gt; &lt;li&gt;gg&lt;/li&gt; &lt;/ul&gt;&lt;/style&gt; 一个元素的 containing block 按以下方式定义： 用户代理（比如浏览器）选择根元素作为 containing block（称之为初始 containing block）。 对于其它元素，除非元素使用的是绝对位置，containing block 由最近的块级祖先元素盒子的内容边界组成。 如果元素有属性 ‘position:fixed’，containing block 由视口建立。 如果元素有属性 ‘position:absolute’，containing block 由最近的 position 不是 static 的祖先建立，按下面的步骤： 如果祖先是块级元素，containing block 由祖先的 padding edge 形成。 如果祖先是内联元素，containing block 取决于祖先的 direction 属性。 如果 direction 是 ltr（左到右），祖先产生的第一个盒子的上、左内容边界是 containing block 的上方和左方，祖先的最后一个盒子的下、右内容边界是 containing block 的下方和右方。 如果 direction 是 rtl（右到左），祖先产生的第一个盒子的上、右内容边界是 containing block 的上方和右方，祖先的最后一个盒子的下、左内容边界是 containing block 的下方和左方。 如果没有祖先，根元素盒子的内容边界确定为 containing block。 visibility的collapse当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 “hidden”。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组操作]]></title>
      <url>%2F2017%2F03%2F06%2F%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[1234567891011function unique1(array)&#123; var n = []; //一个新的临时数组 //遍历当前数组 for(var i = 0; i &lt; array.length; i++)&#123; //如果当前数组的第i已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (n.indexOf(array[i]) == -1) n.push(array[i]); &#125; return n; &#125; 循环遍历嵌套数组1234567891011121314151617181920212223242526function getArray(arr)&#123; var arrs=[]; for(var i=0;i&lt;arr.length;i++)&#123; if(!Array.isArray(arr[i]))&#123; arrs.push(arr[i]) &#125;else&#123; arrs=arrs.concat(getArray(arr[i])) &#125; &#125; return arrs&#125;//法二var arr=[1,[2,[5,6],&#123;value:&apos;ddd&apos;&#125;],4],result=[]function getArray(arr,result)&#123; var temp; for(var i=0;i&lt;arr.length;i++)&#123; temp=arr[i] if(Array.isArray(temp))&#123; getArray(temp,result) &#125;else&#123; result.push(temp) &#125; &#125;&#125;getArray(arr,result) 对象克隆12345678910111213141516function clone(Obj) &#123; var buf; if (Obj instanceof Array) &#123; buf=Array.prototype.slice.call(Obj) return buf; &#125; else if (Obj instanceof Object)&#123; buf = &#123;&#125;; // 创建一个空对象 for (var k in Obj) &#123; // 为这个对象添加新的属性 buf[k] = clone(Obj[k]); &#125; return buf; &#125;else&#123; return Obj; &#125;&#125; 深度克隆 123456789101112131415161718192021222324function deepClone(obj)&#123; var _toString=Object.prototype.toString; if(!obj||typeof obj!==&apos;object&apos;)&#123; return obj; &#125; if(obj.nodeType&amp;&amp;&apos;clone&apos; in obj)&#123; return obj.cloneNode(true) &#125; if(_toString.call(obj)===&apos;[object Date]&apos;)&#123; return new Date(obj.getTime()) &#125; if(_toString.call(obj)===&apos;[object RegExp]&apos;)&#123; var flags=[]; if(obj.global)&#123;flags.push(&apos;g&apos;)&#125; if(obj.multiline)&#123;flags.push(&apos;m&apos;)&#125; if(obj.ignoreCase)&#123;flags.push(&apos;i&apos;)&#125; return new RegExp(obj.source,flags.join(&apos;&apos;)) &#125; var result=Array.isArray(obj)?[]:obj.constructor?new obj.constructor():&#123;&#125; for(var key in obj)&#123; result[key]=deepClone(obj[key]); &#125; return result;&#125; 求数组最大数 1Math.max.apply(null,arr)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[封装函数]]></title>
      <url>%2F2017%2F03%2F06%2F%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[近期看的数据结构貌似呼还是挺有用的然而还是会忘记123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211//栈function Stack() &#123; var items = []; this.push = function (element) &#123; items.push(element); &#125;;//推栈 this.pop = function () &#123; return items.pop(); &#125;;//弹栈 this.peek = function () &#123; return items[items.length - 1]; &#125;;//栈顶元素 this.isEmpty = function () &#123; return items.length === 0; &#125;;//栈是否为空 this.size = function () &#123; return items.length; &#125;;//栈大小 this.clear = function () &#123; items = []; &#125;;//清空栈 this.print = function () &#123; console.log(items.toString()); &#125;;//打印栈&#125;//队列function Queue() &#123; var items = []; this.enqueue = function (element) &#123; items.push(element); &#125;//入队 this.dequeue = function () &#123; return items.shift(); &#125;//出队 this.front = function () &#123; return items[0]; &#125;//队首元素 this.isEmpty = function () &#123; return items.length === 0; &#125;//队列是否为空 this.clear = function () &#123; items = []; &#125;//清空队列 this.size = function () &#123; return items.length; &#125;//队列大小 this.print = function () &#123; console.log(items.toString()); &#125;//打印队列&#125;//圣杯继承var inherit = (function ()&#123; var F = function () &#123;&#125;; return function (Child, Parent) &#123; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.prototype.uber = Parent.prototype; &#125;&#125;)();//深层拷贝对象（不考虑函数）function deepClone(original, target) &#123; var target = target || &#123;&#125;, toStr = Object.prototype.toString, arrStr = '[object Array]'; for(var prop in original)&#123; if(original.hasOwnProperty(prop))&#123; if(typeof original[prop] === 'object')&#123; target[prop] = (toStr.call(original[prop]) === arrStr) ? [] : &#123;&#125;; deepClone(original[prop], target[prop]); &#125;else&#123; target[prop] = original[prop]; &#125; &#125; &#125; return target;&#125;//数组去重Array.prototype.unique = function() &#123; var obj = &#123;&#125;, arr = [], len = this.length; for(var i = 0; i &lt; len; i++)&#123; if(!obj[this[i]])&#123; obj[this[i]] = true; arr.push(this[i]); &#125; &#125; return arr;&#125;//类属性function classOf(o)&#123; if(o === null) return "Null"; if(o === undefined) return "Undefined"; return Object.prototype.toString.call(o).slice(8,-1);&#125;//父节点的第几个元素节点Element.prototype.eleIndex = function()&#123; var index = 0, node = this; while(node = node.previousSibling)&#123; if(node.nodeType == 1)&#123; index++; &#125; &#125; return index;&#125;//第n层祖先元素Element.prototype.nthParentEle = function(n) &#123; var node = this, n = n || 0; while(node &amp;&amp; n--) &#123; node = node.parentElement; &#125; return node;&#125;//第n个兄弟节点Element.prototype.nthSiblingEle = function(n)&#123; var node = this; while(node &amp;&amp; n) &#123; if(n &gt; 0)&#123; if(node.nextElementSibling)&#123; node = node.nextElementSibling; &#125;else&#123; for(node = node.nextSibling; node &amp;&amp; node.nodeType !== 1; node = node.nextSibling); &#125; n--; &#125;else&#123; if(node.previousElementSibling)&#123; node = node.previousElementSibling; &#125;else&#123; for(node = node.previousSibling; node &amp;&amp; node.nodeType !== 1; node = node.previousSibling); &#125; n++; &#125; &#125; return node;&#125;//在某元素后插入元素Element.prototype.insertAfter = function (targetNode, afterNode)&#123; var siblingNode = afterNode.nextElementSibling; if(siblingNode) &#123; this.insertBefore(targetNode,siblingNode); &#125; else &#123; this.appendChild(targetNode); &#125; return targetNode;&#125;//销毁元素节点自身Element.prototype.remove = function ()&#123; this.parentElement.removeChild(this);&#125;//目标节点内部的节点顺序逆序Element.prototype.revChild = function ()&#123; var child = this.children, len = child.length; for (var i = len - 2; i &gt;= 0; i--)&#123; this.appendChild(child[i]); &#125; return this;&#125;//查看滚动轮滚动距离function getScrollOffset()&#123; if(window.pageXOffset)&#123; return &#123; x: window.pageXOffset, y: window.pageYOffset &#125; &#125;else&#123; return &#123; x: document.body.scrollLeft + document.documentElement.scrollLeft, y: document.body.scrollTop + document.documentElement.scrollTop &#125; &#125;&#125;//查看浏览器视口尺寸function getViewportOffset()&#123; if(window.innerWidth)&#123; return &#123; w: window.innerWidth, h: window.innerHeight &#125; &#125;else if(document.compatMode === "CSS1Compat")&#123; return&#123; w: document.documentElement.clientWidth, h: document.documentElement.clientHeight &#125; &#125;else&#123; return&#123; w: document.body.clientWidth, h: document.body.clientHeight &#125; &#125;&#125;//求元素相对于文档的坐标Element.prototype.getCoord = function ()&#123; var coordX = 0, coordY = 0, docEle = this; while(docEle)&#123; coordX += docEle.offsetLeft; coordY += docEle.offsetTop; docEle = docEle.offsetParent; &#125; return &#123; x: coordX, y: coordY &#125;&#125;; 123//获取相对文档的距离var X= this.getBoundingClientRect().left+document.documentElement.scrollLeft; var Y =this.getBoundingClientRect().top+document.documentElement.scrollTop; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147//获取样式function getStyle(ele, style)&#123; if(window.getComputedStyle)&#123; return window.getComputedStyle(ele,null)[style]; &#125;else&#123; return ele.currentStyle[style]; &#125;&#125;//添加事件function addEvent(elem, type, handler)&#123; if(elem.addEventListener)&#123; elem.addEventListener(type, handler, false); &#125;else if(elem.attachEvent)&#123; elem[&apos;temp&apos; + type + handler] = handler; elem[&apos;temp&apos; + type] = function()&#123; elem[&apos;temp&apos; + type + handler].call(elem); &#125; elem.attachEvent(&apos;on&apos; + type, elem[&apos;temp&apos; + type]); &#125;else&#123; elem[&apos;on&apos; + type] = handler; &#125;&#125;//解除事件function removeEvent(elem, type, handler)&#123; if(elem.removeEventListener)&#123; elem.removeEventListener(type, handler, false); &#125;else if(elem.detachEvent)&#123; elem.detachEvent(&apos;on&apos; + type, elem[&apos;temp&apos; + type]); &#125;else&#123; elem[&apos;on&apos; + type] = null; &#125;&#125;//取消冒泡function stopBubble(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125;&#125;//阻止默认事件function cancelHandler(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125;&#125;//拖拽元素function drag(elem)&#123; var disX; var disY; addEvent(elem,&quot;mousedown&quot;,function(e)&#123; var event = e || window.event; disX = event.clientX - parseInt(getStyle(this,&quot;left&quot;)); disY = event.clientY - parseInt(getStyle(this,&quot;top&quot;)); addEvent(document,&quot;mousemove&quot;,mouseMove); addEvent(document,&quot;mouseup&quot;,mouseUp); &#125;); function mouseMove(e)&#123; var event = e || window.event; elem.style.left = event.pageX - disX + &apos;px&apos;; elem.style.top = event.pageY - disY + &apos;px&apos;; &#125; function mouseUp()&#123; removeEvent(document,&quot;mousemove&quot;,mouseMove); removeEvent(document,&quot;mouseup&quot;,mouseUp); &#125;&#125;//多物体多值链式运动框架function startMove(elem, json, func)&#123; clearInterval(elem.timer); var iSpeed; var iCur; var bStop; elem.timer = setInterval(function()&#123; bStop = true; for(var attr in json)&#123; iCur = attr === &apos;opacity&apos; ? parseFloat(getStyle(elem,attr)) * 100 : parseInt(getStyle(elem,attr)); iSpeed = attr === &apos;opacity&apos; ? (parseFloat(json[attr])* 100 - iCur) / 7 : (parseInt(json[attr]) - iCur) / 7; iSpeed = iSpeed &gt; 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed); elem.style[attr] = attr === &quot;opacity&quot; ? (iCur + iSpeed) / 100 : iCur + iSpeed + &apos;px&apos;; if(iCur !== (attr === &apos;opacity&apos; ? parseFloat(json[attr]) * 100 : parseInt(json[attr])))&#123; bStop = false; &#125; &#125; if(bStop)&#123; clearInterval(elem.timer); if(func)&#123; func(); &#125; &#125; &#125;,30);&#125;//按需异步加载scriptfunction scriptLoaded(url, callback)&#123; var script = document.createElement(&apos;script&apos;); script.type = &quot;text/javascript&quot;; if(script.readyState)&#123; script.onreadystatechange = function()&#123; if(script.readyState == &quot;complete&quot; || script.readyState == &quot;loaded&quot;)&#123; callback(); script.onreadystatechange = null; &#125; &#125; &#125;else&#123; script.onload = function()&#123; script.onload = null; callback(); &#125; &#125; script.src = url; document.head.appendChild(script);&#125;//兼容getElementByClassNameDocument.prototype.getByClassName = function(target) &#123; var allEle = document.getElementsByTagName(&apos;*&apos;), len = allEle.length, arr = [], classArr = [], classArrLen; for(var i = 0; i &lt; len; i++) &#123; classArr = allEle[i].className.myTrim().splice(&apos; &apos;); classArrLen = classArr.length; for(var j = 0; j &lt; classArrLen; j++)&#123; if(classArr[j] === target)&#123; arr.push(allEle[i]); break; &#125; &#125; &#125; return arr;&#125;//兼容trimString.prototype.myTrim = function() &#123; var reg = /^\s*|\s*$/; return this.replace(reg,&apos;&apos;);&#125;String.prototype.trim=function()&#123; return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);&#125;String.prototype.ltrim=function()&#123; return this.replace(/(^\s*)/g,&quot;&quot;);&#125;String.prototype.rtrim=function()&#123; return this.replace(/(\s*$)/g,&quot;&quot;);&#125; 123456789101112//共享onload事件function addLoadEvent(func)&#123; var oldLoad=window.onload if(typeof window.onload!=&apos;function&apos;)&#123; window.onload=func &#125;else&#123; window.onload=function()&#123; oldLoad() func() &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[某公司面试]]></title>
      <url>%2F2017%2F03%2F06%2F%E6%9F%90%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%2F</url>
      <content type="text"><![CDATA[sessionstorage、localstorage、cookie区别 cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie **存储大小：** cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 seessionStorage 临时性的，页面打开有，页面关闭没有 数据不共享 通过a标签来跳出一个页面，则sessionStorage共享 localStorage 永久性的存储 不能跨域 数据共享 cookiecookie在同源且符合path规则的文档之间共享 如何实现浏览器内多个标签页之间的通信? WebSocket、SharedWorker； 也可以调用localstorge、cookies等本地存储方式； localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件， 我们通过监听事件，控制它的值来进行页面信息通信； 注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常； 懒加载和预加载 用CSS和JavaScript实现预加载:backgrond 仅使用JavaScript实现预加载 使用Ajax实现预加载 第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟. 第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。 第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。 post和get的区别 正则表达式 bfc如何触发 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible 快速排序和堆排序 盒子模型与box-sizing 翻墙 css和js引入位置浏览器解析html页面首先浏览器先下载html，然后在内存中把html代码转化成Dom Tree，然后浏览器根据Dom Tree上的Node分析css和Images，当文档下载遇到js时，js独立下载。js是阻塞加载，会影响页面加载的速度，如果js文件比较大，算法也比较复杂的话，影响更大。CSS放在前端是页面渲染时首先是根据DOM结构生成一个DOM树然后加上CSS样式生成一个渲染树，如果CSS放在后面可能页面会出现闪跳的感觉，或者是白屏或者布局混乱样式很丑直到CSS加载完成。 rem和em 登录安全性 hashtag和history 画三角形 长连接短连接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2017%2F03%2F05%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[用处： 测试字符串内的模式。例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。可以查找文档内或输入域内特定的文本。 如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。同时，可以通过正则对象的lastIndex属性指定开始搜索的位置。 123456789101112131415var xReg = /x/g;var str = &apos;xyz_x1_y1_x3&apos;;xReg.lastIndex; // 0xReg.test(str); // truexReg.lastIndex; // 1xReg.test(str); // truexReg.lastIndex; // 5// 指定位置开始 指定下次匹配从最后一位开始，就匹配不到了xReg.lastIndex = 11; // 11xReg.test(str); // falsexReg.lastIndex; // 0 实践： 1var indexReg = /^(?:http|https).+\/jwebui\/pages\/themes\/(\w+)\/\1\.jspx(\?\S+)?$/i ; 最开始的^ 和最后的$分别表示匹配的开始和结束。 (?:http|https)表示两者之一，这么写是非获取的组匹配，()不会被分组存储。也可以写成(http|https) 但是后面的\1就需要替换成\2了，因为这么写时此处形成了第一个分组。 .+ 就是任意字符至少出现一次。 \/jwebui\/pages\/themes\/ 就是匹配字符串”/jwebui/pages/themes/“。 (\w+) 作为第一个分组，表示任意字母或数字或下划线或汉字至少出现一次。 \1表示对第一个分组的引用，再重复第一分组的内容 。 .jspx 表示.jspx。 (\?\S+)? 表示(\?\S+) 匹配的内容出现0次或一次。其中:\? 表示？ 。\S+ 表示任意可见字符出现至少一次。将字符串转换为驼峰表示法 123456function toCampStyle(str)&#123; var reg=/-([a-z]+)/ig; return str.replace(reg,function(all,letter)&#123; return letter.slice(0,1).toUpperCase()+letter.slice(1) &#125;)&#125; 检测有无重复字母 123var reg=/([a-zA-Z])\1/g;var str=&apos;aadididi&apos;console.log(reg.test(str)) 实现千分位分隔符 1234function format (num) &#123; var reg=/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g; return (num + &apos;&apos;).replace(reg, &apos;$&amp;,&apos;); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[清除浮动]]></title>
      <url>%2F2017%2F03%2F04%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[清除浮动的方法可以分成两类： 一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。 二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素 父级div定义 height 原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 优点：简单、代码少、容易掌握 缺点：：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 结尾处加空div标签 clear:both 原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 优点：简单、代码少、浏览器支持好、不容易出现怪问题 缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好 父级div定义 伪类:after 和 zoom .clearfloat:after{display:block;clear:both;content:&quot;&quot;;visibility:hidden;height:0} 原理： IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 优点： 浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点： 代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 父级div定义 overflow:hidden 优点：简单、代码少、浏览器支持好 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 父级div 也一起浮动 缺点：会产生新的浮动问题。 父级div定义 display:table]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue实现无限轮播]]></title>
      <url>%2F2017%2F03%2F03%2Fvue%E8%BD%AE%E6%92%AD%2F</url>
      <content type="text"><![CDATA[思路： 要实现无限轮播，需要在轮播图前后各加一张图片，加在前面的是轮播图的最后一张图片（重复的），加在后面的是轮播图的第一张图片（重复的）。例： 12345678&lt;div class=&quot;wrapper-content&quot;&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; src=&quot;img/4.jpg&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; src=&quot;img/1.jpg&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;2&quot; src=&quot;img/2.jpg&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;3&quot; src=&quot;img/3.jpg&quot; /&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; src=&quot;img/4.jpg&quot; /&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; src=&quot;img/1.jpg&quot; /&gt; &lt;/div&gt; 然后再用left来控制滑动，当顺向到达alt为4的图片时，下一张滑到第六张图片，alt为1，同时改变index为1.然后立即将left移到第二张图片，alt为1那张。这样就不会被察觉 好了，贴代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; *&#123;margin: 0;padding: 0&#125; .wrapper&#123;position: relative;overflow: hidden;&#125; .wrapper-content&#123;position: absolute;left: 0;z-index: 1;&#125; .wrapper-content_img&#123;border: none;outline:none;float: left&#125; .wrapper-buttons&#123;position: absolute;width: 100px;height: 20px;text-align: center;bottom: 3px;z-index: 2;&#125; .wrapper-button&#123;float: left;width: 20px;height: 20px;border-radius: 10px;background: gray;margin: 0 2.5px;cursor: pointer;&#125; .wrapper-arrow&#123;position: absolute;width: 40px;height:40px;cursor: pointer;background-color: RGBA(0,0,0,.3); color: #fff;display: none;top:50%;line-height: 40px;font-size: 36px;text-align: center;z-index: 2;&#125; .wrapper:hover .wrapper-arrow&#123;display: block;background-color: rgba(0,0,0,.7);&#125; .wrapper-prev&#123;left:10px;&#125; .wrapper-next&#123;right:10px;&#125; .wrapper_on&#123;background-color: yellow&#125; .wrapper_trans&#123;transition: left .3s ease&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;wrapper&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot; @mouseover=&quot;stop&quot; @mouseout=&quot;play&quot;&gt; &lt;div class=&quot;wrapper-content&quot; :class=&quot;&#123;wrapper_trans:isTrans&#125;&quot; :style=&quot;&#123;width:originalData.img_width*(originalData.num+2)+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;,left:-originalData.img_width+&apos;px&apos;&#125;&quot; ref=&quot;wrapperContent&quot;&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; src=&quot;img/4.jpg&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; src=&quot;img/1.jpg&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;2&quot; src=&quot;img/2.jpg&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;3&quot; src=&quot;img/3.jpg&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; src=&quot;img/4.jpg&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; src=&quot;img/1.jpg&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;wrapper-buttons&quot; :style=&quot;&#123;left:(originalData.img_width-100)/2+&apos;px&apos;&#125;&quot;&gt; &lt;span :class=&quot;[&apos;wrapper-button&apos;,&#123;&apos;wrapper_on&apos;:index==1&#125;]&quot; @click=&quot;turnTo(1)&quot;&gt;&lt;/span&gt; &lt;span :class=&quot;[&apos;wrapper-button&apos;,&#123;&apos;wrapper_on&apos;:index==2&#125;]&quot; @click=&quot;turnTo(2)&quot;&gt;&lt;/span&gt; &lt;span :class=&quot;[&apos;wrapper-button&apos;,&#123;&apos;wrapper_on&apos;:index==3&#125;]&quot; @click=&quot;turnTo(3)&quot;&gt;&lt;/span&gt; &lt;span :class=&quot;[&apos;wrapper-button&apos;,&#123;&apos;wrapper_on&apos;:index==4&#125;]&quot; @click=&quot;turnTo(4)&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;wrapper-arrow wrapper-prev&quot; :style=&quot;&#123;marginTop:-originalData.btn_width/2+&apos;px&apos;&#125;&quot; @click=&quot;prev&quot;&gt;&amp;lt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;wrapper-arrow wrapper-next&quot; :style=&quot;&#123;marginTop:-originalData.btn_width/2+&apos;px&apos;&#125;&quot; @click=&quot;next&quot;&gt;&amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;a href=&quot;#&quot; style=&quot;width: 50px;height: 50px;position: absolute;top: 500px;&quot;&gt;aaa&lt;/a&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://unpkg.com/vue@2.1.10/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&apos;#app&apos;, data:&#123; originalData:&#123; img_width:350, img_height:350, btn_width:40, btn_height:40, num:4, delay:300 &#125;, isTrans:true,//因为到最后一张图片，index为1时，需要立即跳到第二张index也为1的图片，这个用来是否给出transition index:1, timer:null,//setInterval clickdelay:false//用来防止连续点击 &#125;, methods:&#123; next()&#123; if(this.clickdelay)&#123; return &#125; this.clickdelay=true if(this.index==this.originalData.num)&#123; this.index=1 &#125;else&#123; this.index+=1 &#125; this.animate(this.originalData.img_width) &#125;, prev()&#123; if(this.clickdelay)&#123; return &#125; this.clickdelay=true if(this.index==1)&#123; this.index=this.originalData.num &#125;else&#123; this.index-=1 &#125; this.animate(-this.originalData.img_width) &#125;, animate(offset)&#123; var node=this.$refs.wrapperContent var self=this; var left=parseInt(node.style.left)-offset this.isTrans=true node.style.left=left+&apos;px&apos; setTimeout(function()&#123; if(left&lt;-(self.originalData.num*self.originalData.img_width))&#123; self.isTrans=false node.style.left=-self.originalData.img_width+&apos;px&apos; self.clickdelay=false //当到达最后一张图片时 &#125; if(left&gt;-100)&#123; self.isTrans=false node.style.left=-self.originalData.num*self.originalData.img_width+&apos;px&apos; self.clickdelay=false //当到达第一张图片时 &#125; &#125;,this.originalData.delay) &#125;, play()&#123; var self=this; this.timer=setInterval(function()&#123; self.next() &#125;,2000) &#125;, stop()&#123; this.clickdelay=false//用来防止连续点击 clearInterval(this.timer) this.timer=null &#125;, turnTo(flag)&#123; if(flag==this.index)&#123; return &#125;else&#123; var offset=(flag-this.index)*this.originalData.img_width this.index=flag this.animate(offset) &#125; &#125; &#125;, mounted()&#123; /*下面是判断过渡动画是否完成*/ var node=this.$refs.wrapperContent var transitions = &#123; &apos;transition&apos;:&apos;transitionend&apos;, &apos;OTransition&apos;:&apos;oTransitionEnd&apos;, &apos;MozTransition&apos;:&apos;transitionend&apos;, &apos;WebkitTransition&apos;:&apos;webkitTransitionEnd&apos; &#125; var self=this for(var t in transitions)&#123; if( node.style[t] !== undefined )&#123; var transitionEvent=transitions[t]; &#125; &#125; transitionEvent &amp;&amp; node.addEventListener(transitionEvent, function() &#123; self.clickdelay=false &#125;); this.play() &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 由于是封装的，高度宽度好多写在了内联style里]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[margin坍塌]]></title>
      <url>%2F2017%2F03%2F03%2FmarginNoUse%2F</url>
      <content type="text"><![CDATA[今天在写代码过程中，解决了一个小问题，代码如下。在.first的div中设置margin-top，效果却是和父div设置margin-top一样，网上又搜了答案总结一下 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .main&#123;height: 400px;width: 200px;background: yellow;&#125; .first&#123;width: 100px;height: 100px;background: red;margin-bottom: 50px;margin-top: 100px;margin-right: 0px&#125; .second&#123;width: 100px;height: 100px;background: black;margin-top: 100px&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;first&quot;&gt;&lt;/div&gt; &lt;div class=&quot;second&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 解决办法: 在父层div加上：overflow:hidden； 把margin-top外边距改成padding-top内边距 ； 父元素产生边距重叠的边有不为 0 的 padding 或宽度不为 0 且 style 不为 none 的 border。父层div加： padding-top: 1px;或者border:1px solid black 让父元素生成一个 block formating context，以下属性可以实现 float: left/right position: absolute display: inline-block/table-cell(或其他 table 类型) overflow: hidden/auto父层div加：position: absolute;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cssRule那些事]]></title>
      <url>%2F2017%2F03%2F02%2Fcssrules%2F</url>
      <content type="text"><![CDATA[div.style.cssText返回内联样式，并且可以改变 1234567&lt;style&gt; .main&#123;width: 100px;height: 200px;background: red&#125;&lt;/style&gt;&lt;div class=&quot;main&quot; style=&quot;margin:10px&quot;&gt;&lt;/div&gt;var el=document.querySelector(&apos;.main&apos;)el.style.cssText//margin:10px getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，只读。 用法 ：var style = window.getComputedStyle(“元素”, “伪类”);或者 ：document.defaultView.getComputedStyle(“元素”, “伪类”) 在ie中用currentStyle属性 12var computedStyle=mydiv.currentStyle 操作样式表 document.styleSheets返回StyleSheetList {0: CSSStyleSheet, length: 1} 通过style或者sheet取得CSSStyleSheet 1234var link=document.getElementsByTagName(&apos;link&apos;)[0];function getStyleSheet(element)&#123; return element.sheet||element.styleSheet&#125; css规则 123456789101112131415161718var sheet=document.styleSheets[1];//这个下还有addRule，deleteRule,insertRule(&quot;body&#123;background-color:silver&#125;&quot;,0)等方法var rules=sheet.cssRules||sheet.rules;var rule=rules[0];console.log(rule)///*CSSStyleRule &#123;selectorText: &quot;.main&quot;, style: CSSStyleDeclaration, type: 1, cssText: &quot;.main &#123; width: 100px; height: 200px; background: red; &#125;&quot;, parentRule: null…&#125;cssText:&quot;.main &#123; width: 100px; height: 200px; background: red; &#125;&quot;parentRule:nullparentStyleSheet:CSSStyleSheetselectorText:&quot;.main&quot;style:CSSStyleDeclarationtype:1__proto__:CSSStyleRule*/console.log(rule.style.width)//100px]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用requestAnimationFrame做轮播]]></title>
      <url>%2F2017%2F03%2F01%2Farticle-title%2F</url>
      <content type="text"><![CDATA[用setTimeout和setInterval来实现动画 没有对调用动画的循环机制进行优化 即使传递毫秒为单位的参数，也不能打到ms的准确性。因为JavaScript是单线程的，可能发生阻塞 没有考虑绘制动画的最佳时机 requestAniamationFrame requestAnimationFrame不需要使用者指定循环间隔时间，浏览器会基于当前页面是否可见、CPU的负荷情况等来自行决定最佳的帧速率，从而更合理地使用CPU。 如果想做逐帧动画，就应该用这个方法，这就要求动画函数执行会先于浏览器重绘动作。通常，被调用的频率是每秒60次。 回调函数只会传入一个DOMHighResTimeStamp参数，表示函数队列被触发的时间。 requestAnimationFrame返回一个id，用于window.cancelAnimationFrame(id)来取消这个回调函数 兼容代码： 1234567891011121314151617181920212223242526window.requestAnimationFrame=window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback, element) &#123; var start, finish; window.setTimeout(function () &#123; start = +new Date(); callback(start); finish = +new Date(); self.timeout = 1000 / 60 - (finish - start); &#125;, self.timeout); &#125;; window.cancelNextRequestAnimationFrame = window.cancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout; requestAnimationFrame做的简易动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; *&#123;padding:0;margin: 0&#125; .outer&#123;width: 100px;height: 100px;overflow:hidden;position: relative;&#125; .inner&#123; height:100px;list-style-type:none;width: 400px; &#125; .inner:after&#123;height: 0;content: '';clear: both;visibility: hidden;&#125; .inner li&#123;float: left;width: 100px;height: 100px&#125; li:nth-child(1)&#123;background: red&#125; li:nth-child(2)&#123;background: black&#125; li:nth-child(3)&#123;background: yellow&#125; li:nth-child(4)&#123;background: green&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="outer"&gt; &lt;ul class="inner"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;button&gt;下一步&lt;/button&gt; &lt;script type="text/javascript"&gt; var start = null; var element = document.querySelector('.inner') element.style.position = 'absolute'; var cur=0,mm=100,timeid function step(timestamp) &#123; if (!start) start = timestamp; var progress = timestamp - start; if(cur==3)&#123; element.style.left=0; &#125;else&#123; element.style.left = -Math.min(progress / 10+cur*100, (cur+1)*100) + 'px'; &#125; if (progress &lt; 1000) &#123; timeid=window.requestAnimationFrame(step); &#125;else&#123; cur=cur&lt;3?cur+1:0 window.cancelAnimationFrame(timeid) timeid=null start=null setTimeout(auto,1000) &#125; &#125; var btn=document.querySelector('button') btn.onclick=function()&#123; auto() &#125; function auto()&#123; if(!timeid)&#123; console.log(cur) timeid=window.requestAnimationFrame(step); &#125; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个vue2.0+vuex+vue-router搭建的单页潮流购物网站]]></title>
      <url>%2F2017%2F01%2F22%2Ffashion%2F</url>
      <content type="text"><![CDATA[项目demo地址github源码地址 首页 觉得不错，给我的github源码点个赞吧QAQ 前言这篇文章是总结自己写项目时的思路，遇到的问题，和学到的东西，本文只截取一部分来讲，源码已奉上，觉得项目还行的点个赞吧，谢谢 一、搭建环境 安装vue-cli npm install -g vue-cli 创建webpack项目 vue init webpack voguecd vogue 安装依赖 npm install 安装vue-router npm install vue-router –save-dev 安装vuex npm install vuex –save-dev 运行 npm run dev 二、目录结构 components中是所有页面组件 store中的index.js存放了vuex状态管理的东西，此处本应分成actions.js,mutations.js,getters.js的，可是我试了很多次没成功，还是将他们放在一个文件中，显得有点冗余了，这点失误了，会找原因的 static中存放了图片，图片是压缩了的，网站是https://tinypng.com/，还存放了字体，和一点css，css放在这里有一个原因就是，我想给某个元素设置background时，将style写在static里才行。 dist文件是后来npm run build后生成的，生成的dist中的index.html中的link都是没有加引号的，我自己加上才可以直接运行 三、项目开发开发过程中，页面是一个一个写的，不过还是要先确定路由，路由嵌套 main.js先说说路由吧，写在了main.js中，直接上图 文章开头有首页，home的路径就是’home’，这里路由嵌套，用‘:id’来识别，Brands.vue组件在后文中会解释如何得到id，home页的八个导航，分别导向‘/home’,‘/news’，‘/collections’,‘/shop’,‘/home/clot’,‘/home/madness’,‘/home/bape’,‘/home/assc’,购物车导向‘/cart’,‘login|register’导向‘/login’,‘/newsarticle’是在news组件中导向的，‘/shoppingitem’是shop组件中导向的 App.vue v-for列表渲染的数据如left_navs和contents均来自state 对象迭代 &lt;div v-for=&quot;(value, key, index) in object&quot;&gt; {{ index }}. {{ key }} : {{ value }} &lt;/div&gt; 如何得到state中的数据 1234567891011import &#123;mapGetters&#125; from &apos;vuex&apos; computed:&#123; ...mapGetters(&#123; show:&apos;getShow&apos;, items:&apos;getFootItems&apos;, cart:&apos;getCart&apos;, brands:&apos;getBrands&apos;, left_navs:&apos;getLeft_nav&apos; &#125;) &#125;, 在布局上，我的思路是： 首页三行，上下定高，中间自适应高度，于是在app.vue的created()中设置事件委托 12345678910111213141516171819202122232425262728 var self=this; window.onload=()=&gt;&#123; this.$store.dispatch(&apos;change_hw&apos;,&#123; h:document.documentElement.clientHeight||document.body.clientHeight, w:document.documentElement.clientWidth||document.body.clientWidth &#125;) &#125; window.onresize=()=&gt;&#123; if(self.timer)&#123; clearTimeout(self.timer) &#125; self.timer=setTimeout(function()&#123; self.$store.dispatch(&apos;change_hw&apos;,&#123; h:document.documentElement.clientHeight||document.body.clientHeight, w:document.documentElement.clientWidth||document.body.clientWidth &#125;) &#125;,100) &#125; window.onscroll=()=&gt;&#123; var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop; if(scrollTop&gt;10)&#123; this.scroll=true; &#125;else&#123; this.scroll=false; &#125; &#125;&#125; 然后中间那行用的三栏布局，左右定宽中间自适应宽度，再设置一个min-height不免得将中间的轮播弄来没有了，具体见css 细节： 其中用data中的scroll，用来显示可以让页面一键划到顶端的按钮，滑动动画代码如下 123456789101112131415161718192021222324252627282930313233scrolltoTop:()=&gt;&#123; if(document.documentElement.scrollTop)&#123; var scrollTop=document.documentElement.scrollTop var step=scrollTop/30; var now=scrollTop-step; var i=0; var time=setInterval(function()&#123; i++; if(i&gt;32)&#123; clearInterval(time) &#125; document.documentElement.scrollTop=now; scrollTop=document.documentElement.scrollTop now=scrollTop-step; &#125;,10) &#125;else if(document.body.scrollTop)&#123; var scrollTop=document.body.scrollTop var step=scrollTop/30; var now=scrollTop-step; var i=0; var time=setInterval(function()&#123; i++; if(i&gt;32)&#123; clearInterval(time) &#125; document.body.scrollTop=now; scrollTop=document.body.scrollTop now=scrollTop-step; &#125;,10) &#125; &#125;, 这里比较坑的地方就是document.documentElement.scrollTop和document.documentElement.scrollTop需要注意 Home.vue这里给出了brands的样式，也就是说导航栏的home，clot，madness，bape，assc都有这个组件， HomeFirst.vue2.21号修改重新改了下轮播，通过改变left来实现无限轮播，思路如下： 123456789&lt;div class=&quot;wrapper-content&quot; :class=&quot;&#123;wrapper_trans:isTrans&#125;&quot; :style=&quot;&#123;width:originalData.img_width*(originalData.num+2)+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;,left:-originalData.img_width+&apos;px&apos;&#125;&quot; ref=&quot;wrapperContent&quot;&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; :src=&quot;&apos;../static/images/home_4.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; :src=&quot;&apos;../static/images/home_1.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;2&quot; :src=&quot;&apos;../static/images/home_2.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;3&quot; :src=&quot;&apos;../static/images/home_3.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; :src=&quot;&apos;../static/images/home_4.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; :src=&quot;&apos;../static/images/home_1.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt;&lt;/div&gt; 共四张图片，前后再加一张，变成六张，当向后滚动到第五张时，index为4，下一次滚动，滚动到第六张结束后立即跳到第二张，index依然为3。向前滑动道理一样 methods如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130export default &#123; data ()&#123; return &#123; originalData:&#123; img_width:350, img_height:350, btn_width:40, btn_height:40, num:4, delay:300 &#125;, isTrans:true,//因为到最后一张图片，index为1时，需要立即跳到第二张index也为1的图片，这个用来是否给出transition index:1, timer:null,//setInterval clickdelay:false//用来防止连续点击 &#125; &#125;, computed:&#123; ...mapGetters(&#123; hw:&apos;getHW&apos; &#125;), home_first_width:function()&#123; return parseInt(this.hw.w)-400; &#125;, home_first_height:function()&#123; var a= parseInt(this.hw.h)-200 return a&lt;389?389:a &#125;, home_first_height_margin:function()&#123; return parseInt(this.home_first_height-300)/2 &#125; &#125;, methods:&#123; next()&#123; if(this.clickdelay)&#123; return &#125; this.clickdelay=true if(this.index==this.originalData.num)&#123; this.index=1 &#125;else&#123; this.index+=1 &#125; this.animate(this.originalData.img_width) &#125;, prev()&#123; if(this.clickdelay)&#123; return &#125; this.clickdelay=true if(this.index==1)&#123; this.index=this.originalData.num &#125;else&#123; this.index-=1 &#125; this.animate(-this.originalData.img_width) &#125;, animate(offset)&#123; var node=this.$refs.wrapperContent var self=this; var left=parseInt(node.style.left)-offset this.isTrans=true node.style.left=left+&apos;px&apos; setTimeout(function()&#123; if(left&lt;-(self.originalData.num*self.originalData.img_width))&#123; self.isTrans=false node.style.left=-self.originalData.img_width+&apos;px&apos; self.clickdelay=false //当到达最后一张图片时 &#125; if(left&gt;-100)&#123; self.isTrans=false node.style.left=-self.originalData.num*self.originalData.img_width+&apos;px&apos; self.clickdelay=false //当到达第一张图片时 &#125; &#125;,this.originalData.delay) &#125;, play()&#123; var self=this; this.timer=setInterval(function()&#123; self.next() &#125;,2000) &#125;, stop()&#123; this.clickdelay=false//用来防止连续点击 clearInterval(this.timer) this.timer=null &#125;, turnTo(flag)&#123; if(flag==this.index)&#123; return &#125;else&#123; var offset=(flag-this.index)*this.originalData.img_width this.index=flag this.animate(offset) &#125; &#125; &#125;, mounted()&#123; /*下面是判断过渡动画是否完成*/ var node=this.$refs.wrapperContent var transitions = &#123; &apos;transition&apos;:&apos;transitionend&apos;, &apos;OTransition&apos;:&apos;oTransitionEnd&apos;, &apos;MozTransition&apos;:&apos;transitionend&apos;, &apos;WebkitTransition&apos;:&apos;webkitTransitionEnd&apos; &#125; var self=this for(var t in transitions)&#123; if( node.style[t] !== undefined )&#123; var transitionEvent=transitions[t]; &#125; &#125; transitionEvent &amp;&amp; node.addEventListener(transitionEvent, function() &#123; self.clickdelay=false &#125;); this.play() &#125;, created()&#123; this.$store.dispatch(&apos;changeShow&apos;,&apos;home&apos;) &#125; &#125; Shop.vue1234567891011121314 methods:&#123; changeLike(index)&#123; this.$store.dispatch(&apos;changeLike&apos;,index)//改变是否喜欢 &#125;, changeFlagTrue(index)&#123; this.$store.dispatch(&apos;changeFlagTrue&apos;,index)//改变是否显示喜欢 &#125;, changeFlagFalse(index)&#123; this.$store.dispatch(&apos;changeFlagFalse&apos;,index)//改变是否显示喜欢 &#125;, changeSelectedItem(index)&#123; this.$store.dispatch(&apos;changeSelectedItem&apos;,index)//改变进入商品 &#125;&#125; 每个商品被点击时都要改变进入的是哪个商品，changeSelectedItem来完成，这个页面想法来源于1626潮牌网，觉得挺好看的，于是自己写了下来，尤其是mouseover显示的是否喜欢，处理的还是可以，不过chrome和Firefox还是会有闪烁的效果没有处理好 shoppingitem.vue这个组件中重要的就是数量的增减，因为每个商品都有一个对象存储数据，并且加入购物车还需要判断购物车中是否有相同信息的商品，还有点击加入购物车后直接跳转到购物车页面，方法如下123456789101112131415161718192021222324 methods:&#123; changeSize(index)&#123; this.$store.dispatch(&apos;changeSize&apos;,index) &#125;, changeColor(num)&#123; this.$store.dispatch(&apos;changeColor&apos;,num) &#125;, changeNumSub()&#123; if(this.item.num&gt;1)&#123; this.$store.dispatch(&apos;changeNumSub&apos;) &#125; &#125;, changeNumAdd()&#123; if(this.item.num&lt;8)&#123; this.$store.dispatch(&apos;changeNumAdd&apos;) &#125; &#125;, addToCart()&#123; if(!!this.item.color&amp;&amp;!!this.item.size)&#123; this.$store.dispatch(&apos;addToCart&apos;) &#125; &#125;&#125; index.js中的方法如下1234567891011121314151617181920212223242526272829ADD_TO_CART(state)&#123; var cart=state.cart; var thing=mutations.clone(state.selectedItem); //查看购物车是否已经有相同的商品，信息都一样 if(!cart.length)&#123; cart.push(thing) &#125;else&#123; var flag=cart.some(function(e)&#123; return e.color==thing.color&amp;&amp;e.size==thing.size&amp;&amp;e.src==thing.src &#125;) try&#123; if(!flag)&#123; cart.push(thing); throw new Error(&quot;can&apos;t find&quot;) &#125; cart.forEach(function(e,index)&#123; if(e.color==thing.color&amp;&amp;e.size==thing.size&amp;&amp;e.src==thing.src)&#123; cart[index].num+=thing.num; foreach.break=new Error(&quot;StopIteration&quot;); &#125; &#125;) &#125;catch(e)&#123; //用于跳出循环 &#125; &#125; state.selectedItem=&#123;&#125;; &#125;, 添加到购物车中的方法中，我用try，catch来跳出forEach循环，还有这句state.selectedItem={};如果state.selectedItem是直接引用别的对象，那么另一个对象也会跟着改变，为了避免引用，我用了如下方法 123456789101112//js复制对象 clone(myObj)&#123; if(typeof(myObj) != &apos;object&apos;) return myObj; if(myObj == null) return myObj; var myNewObj = new Object(); for(var i in myObj) myNewObj[i] = mutations.clone(myObj[i]); return myNewObj; &#125;, Brands.vue 在created(){}中用this.$route.params.id来得到进入那个路由,因为这四个brand布局样式什么的大致都一样，然后watch来检测this.$route.params.id的改变，以此来getIntro也就是每个brand的数据 组件的介绍大致就是这些 四、Vuex我在vuex这里没有做好，状态和数据应该分开，而且actions，mutations，getters，state，应该分开，不然太冗余了 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。这个状态自管理应用包含以下几个部分：state，驱动应用的数据源；view，以声明方式将state映射到视图；actions，响应在view上的用户输入导致的状态变化。 index.js中的state大概罗列一点123456789101112131415161718const state=&#123; loginway:&apos;&apos;, show:&apos;home&apos;, clientheight:0, clientwidth:0, footItems:[ &#123;title:&apos;ABOUT US&apos;,contents:&#123;content_1:&apos;contact us&apos;,content_2:&apos;about vogue&apos;&#125;&#125;, &#123;title:&apos;SERVICE&apos;,contents:&#123;content_1:&apos;payment methods&apos;,content_2:&apos;track order&apos;&#125;&#125;, &#123;title:&apos;POLICY&apos;,contents:&#123;content_1:&apos;privacy policy&apos;,content_2:&apos;terms &amp; condition&apos;&#125;&#125;, &#123;title:&apos;FOLLOW US&apos;,contents:&#123;content_1:&apos;Facebook&apos;,content_2:&apos;Instagram&apos;&#125;&#125;, ], left_nav:&#123; home:&apos;home&apos;, news:&apos;news&apos;, collections:&apos;collections&apos;, shop:&apos;shop&apos; &#125;,] index.js中的mutations1234567891011121314151617181920const mutations=&#123; CHANGE_HW(state,obj)&#123; state.clientwidth=obj.w; state.clientheight=obj.h; &#125;, CHANGE_SHOW(state,type)&#123; state.show=type &#125;, CHANGE_NOWBRAND(state,type)&#123; state.nowbrand=type+&apos;Intro&apos; &#125;, CHANGE_LIKE(state,index)&#123; state.goods[index].isLike=!state.goods[index].isLike; if(!state.goods[index].isLike)&#123; state.goods[index].likes+=1 &#125;else&#123; state.goods[index].likes-=1 &#125; &#125;,&#125; 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： index.js中的actions1234567891011121314const actions=&#123; change_hw(&#123;commit&#125;,obj)&#123; commit(&apos;CHANGE_HW&apos;,obj) &#125;, changeShow(&#123;commit&#125;,type)&#123; commit(&apos;CHANGE_SHOW&apos;,type) &#125;, changeNowbrand(&#123;commit&#125;,type)&#123; commit(&apos;CHANGE_NOWBRAND&apos;,type) &#125;, changeLike(&#123;commit&#125;,index)&#123; commit(&apos;CHANGE_LIKE&apos;,index) &#125;,&#125; Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 index.js中的getters1234567891011121314151617const getters=&#123; getHW:function(state)&#123; return &#123; h:state.clientheight, w:state.clientwidth &#125; &#125;, getBrands:function(state)&#123; return state.brandsArr &#125;, getLeft_nav:function(state)&#123; return state.left_nav &#125;, getShow:function(state)&#123; return state.show &#125;&#125; 有时候我们需要从 store 中的 state 中派生出一些状态,或用于得到信息 五、总结自己写的这个项目，蛮有收获的，遇到了问题到处问，都解决的差不多了，下面罗列了一些收货和本项目的不足 Firefox中不支持 table 的 min-height CSS 的话 考虑用 normalize.css解决不同浏览器初始样式不一样的问题 css 的命名啥的可以参考一下 BEM 的命名规范 代码组织有点杂乱 vuex只要专心做页面状态管理，尽量不要掺杂页面数据 &lt;input type=&quot;checkbox&quot; @change=&quot;selectAll&quot; id=&quot;selectAll&quot; v-model=&quot;isAll&quot;/&gt;此处的isAll是从state中get到得数据，可以被改变，我自己尝试得到的这个结论 轮播还需要改进 第一次在gh-pages中显示时，发现图片加载太慢 ，于是我把图片压缩了 在用git上传代码是出过差错，解决了。 最后感谢您能阅读到这里，本人小白，努力学习中，献丑了。 参考资料 Vue2.0中文文档：https://cn.vuejs.org/ Vue-router2.0中文文档：http://router.vuejs.org/zh-cn/essentials/getting-started.html Vuex2.0中文文档：http://router.vuejs.org/zh-cn/essentials/getting-started.html git教程：http://www.liaoxuefeng.com/]]></content>
    </entry>

    
  
  
</search>
