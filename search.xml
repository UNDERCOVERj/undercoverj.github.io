<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[想说]]></title>
      <url>%2F2017%2F04%2F03%2Fdaily1%2F</url>
      <content type="text"><![CDATA[折腾hexo两天了，让我对那些牛逼的人又心生崇拜了然而还有些功能没加，又丑又慢，下面进入正题 3月结束了，过得好累啊3月，但4月会更累。。。学校里的樱花都开了，浪多berber嬢嬢些都在照相。一同学都和女朋友跑武大去看樱花咯。而我们。。。前面那女生还是同学的朋友来坐一下。活得不累，活的gay啊！3月中旬投了一个成都的小公司，结果被面得我毫无自信了。然后就看面经，看计网，看数据结构，可是还是好差。。。网申了几家公司，但笔试好坑好坑，估计一家都不得给面试。（怀疑人生中） 但我觉得现在得生活好充实，忙碌吧但又自由，最主要是有几个志同道合的同学，生活还是比高三那会舒服。不知不觉还是快要高考了，又想到那个不知天高地厚的自己，觉得最差也要考个川大，结果啪啪啪打脸了吧但现在觉得还是不咋个。当初也不造咋选了计算机，可能觉得高大上吧。结果进学校就被c语言弄的怀疑人生。感觉什么都不懂更懵逼的是当时一个班学长说来辅导我们高数啊什么的，他说我们有问题就去二教五楼找他，他随时在那儿。当时我就觉得，握草，这学长这么牛批，换我怎么也做不到，都不打游戏吗，结果我现在就是他那样了?我就是因为刚开始太闲了，要不就是睡觉，最后无奈玩上了游戏，一玩就不得了了，沉浸于自我无法自拔，比照镜子还有成就感。但我觉得那会游戏维持了我跟高中兄弟的联系，大学同学也赞同我说法。现在不玩了，兄弟就都在心中了，因为大家都开始忙了，等回家了再一醉方休。讲真好久没有跟熟识的人聊天了。不知道他们过得咋样呢。不过我晓得他们背单词牛批的很，100多天的打卡。我这学期刚开始也在打，结果最多一周。和寝室考研的兄弟伙些一样，他们也只坚持了1周的早起。 有点困咯，晕乎乎你以为要结束了，no 今天是我爸的生日 不对是昨天，3号生日快乐啊爸爸，好久没陪爸爸过生日了。惭愧至极。我也不造为什么我本来能说个不停的人，在家人面前就始终说不出来，从小到大都这样，是不是要看哈心里医生啊。好久没有和爸爸合照了，突然好想家人啊。这学期过了我要常回家了，感觉家乡的人都觉得我消失了一样。每次三姑六婆都在说自己孩子怎么的时候，我想爸妈一定会有失落吧，“俊杰总不喜欢和我们分享自己的事”。但是我也不是不喜欢，怎么说呢，从小到大都是这样，已经习惯了，难过的事不会告诉他们，高兴的事也偶尔告诉他们。我真的，不管今后再外面闯的什么个层次，我心里永远都觉得自己是失败的。我做的不好，我也不知道怎么做好。照片是08年的时候吧好像，我妈弄在微信里发给我的，那时候笑的好灿烂，但这分钟我哭了。。 我爱你们愿望 家人平安健康]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个vue2.0+vuex+vue-router搭建的单页潮流购物网站]]></title>
      <url>%2F2017%2F01%2F22%2Ffashion%2F</url>
      <content type="text"><![CDATA[项目demo地址github源码地址 首页 觉得不错，给我的github源码点个赞吧QAQ 前言这篇文章是总结自己写项目时的思路，遇到的问题，和学到的东西，本文只截取一部分来讲，源码已奉上，觉得项目还行的点个赞吧，谢谢 一、搭建环境 安装vue-cli npm install -g vue-cli 创建webpack项目 vue init webpack voguecd vogue 安装依赖 npm install 安装vue-router npm install vue-router –save-dev 安装vuex npm install vuex –save-dev 运行 npm run dev 二、目录结构 components中是所有页面组件 store中的index.js存放了vuex状态管理的东西，此处本应分成actions.js,mutations.js,getters.js的，可是我试了很多次没成功，还是将他们放在一个文件中，显得有点冗余了，这点失误了，会找原因的 static中存放了图片，图片是压缩了的，网站是https://tinypng.com/，还存放了字体，和一点css，css放在这里有一个原因就是，我想给某个元素设置background时，将style写在static里才行。 dist文件是后来npm run build后生成的，生成的dist中的index.html中的link都是没有加引号的，我自己加上才可以直接运行 三、项目开发开发过程中，页面是一个一个写的，不过还是要先确定路由，路由嵌套 main.js先说说路由吧，写在了main.js中，直接上图 文章开头有首页，home的路径就是’home’，这里路由嵌套，用‘:id’来识别，Brands.vue组件在后文中会解释如何得到id，home页的八个导航，分别导向‘/home’,‘/news’，‘/collections’,‘/shop’,‘/home/clot’,‘/home/madness’,‘/home/bape’,‘/home/assc’,购物车导向‘/cart’,‘login|register’导向‘/login’,‘/newsarticle’是在news组件中导向的，‘/shoppingitem’是shop组件中导向的 App.vue v-for列表渲染的数据如left_navs和contents均来自state 对象迭代 &lt;div v-for=&quot;(value, key, index) in object&quot;&gt; {{ index }}. {{ key }} : {{ value }} &lt;/div&gt; 如何得到state中的数据 1234567891011import &#123;mapGetters&#125; from &apos;vuex&apos; computed:&#123; ...mapGetters(&#123; show:&apos;getShow&apos;, items:&apos;getFootItems&apos;, cart:&apos;getCart&apos;, brands:&apos;getBrands&apos;, left_navs:&apos;getLeft_nav&apos; &#125;) &#125;, 在布局上，我的思路是： 首页三行，上下定高，中间自适应高度，于是在app.vue的created()中设置事件委托 12345678910111213141516171819202122232425262728 var self=this; window.onload=()=&gt;&#123; this.$store.dispatch(&apos;change_hw&apos;,&#123; h:document.documentElement.clientHeight||document.body.clientHeight, w:document.documentElement.clientWidth||document.body.clientWidth &#125;) &#125; window.onresize=()=&gt;&#123; if(self.timer)&#123; clearTimeout(self.timer) &#125; self.timer=setTimeout(function()&#123; self.$store.dispatch(&apos;change_hw&apos;,&#123; h:document.documentElement.clientHeight||document.body.clientHeight, w:document.documentElement.clientWidth||document.body.clientWidth &#125;) &#125;,100) &#125; window.onscroll=()=&gt;&#123; var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop; if(scrollTop&gt;10)&#123; this.scroll=true; &#125;else&#123; this.scroll=false; &#125; &#125;&#125; 然后中间那行用的三栏布局，左右定宽中间自适应宽度，再设置一个min-height不免得将中间的轮播弄来没有了，具体见css 细节： 其中用data中的scroll，用来显示可以让页面一键划到顶端的按钮，滑动动画代码如下 123456789101112131415161718192021222324252627282930313233scrolltoTop:()=&gt;&#123; if(document.documentElement.scrollTop)&#123; var scrollTop=document.documentElement.scrollTop var step=scrollTop/30; var now=scrollTop-step; var i=0; var time=setInterval(function()&#123; i++; if(i&gt;32)&#123; clearInterval(time) &#125; document.documentElement.scrollTop=now; scrollTop=document.documentElement.scrollTop now=scrollTop-step; &#125;,10) &#125;else if(document.body.scrollTop)&#123; var scrollTop=document.body.scrollTop var step=scrollTop/30; var now=scrollTop-step; var i=0; var time=setInterval(function()&#123; i++; if(i&gt;32)&#123; clearInterval(time) &#125; document.body.scrollTop=now; scrollTop=document.body.scrollTop now=scrollTop-step; &#125;,10) &#125; &#125;, 这里比较坑的地方就是document.documentElement.scrollTop和document.documentElement.scrollTop需要注意 Home.vue这里给出了brands的样式，也就是说导航栏的home，clot，madness，bape，assc都有这个组件， HomeFirst.vue2.21号修改重新改了下轮播，通过改变left来实现无限轮播，思路如下： 123456789&lt;div class=&quot;wrapper-content&quot; :class=&quot;&#123;wrapper_trans:isTrans&#125;&quot; :style=&quot;&#123;width:originalData.img_width*(originalData.num+2)+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;,left:-originalData.img_width+&apos;px&apos;&#125;&quot; ref=&quot;wrapperContent&quot;&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; :src=&quot;&apos;../static/images/home_4.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; :src=&quot;&apos;../static/images/home_1.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;2&quot; :src=&quot;&apos;../static/images/home_2.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;3&quot; :src=&quot;&apos;../static/images/home_3.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; :src=&quot;&apos;../static/images/home_4.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; :src=&quot;&apos;../static/images/home_1.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt;&lt;/div&gt; 共四张图片，前后再加一张，变成六张，当向后滚动到第五张时，index为4，下一次滚动，滚动到第六张结束后立即跳到第二张，index依然为3。向前滑动道理一样 methods如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130export default &#123; data ()&#123; return &#123; originalData:&#123; img_width:350, img_height:350, btn_width:40, btn_height:40, num:4, delay:300 &#125;, isTrans:true,//因为到最后一张图片，index为1时，需要立即跳到第二张index也为1的图片，这个用来是否给出transition index:1, timer:null,//setInterval clickdelay:false//用来防止连续点击 &#125; &#125;, computed:&#123; ...mapGetters(&#123; hw:&apos;getHW&apos; &#125;), home_first_width:function()&#123; return parseInt(this.hw.w)-400; &#125;, home_first_height:function()&#123; var a= parseInt(this.hw.h)-200 return a&lt;389?389:a &#125;, home_first_height_margin:function()&#123; return parseInt(this.home_first_height-300)/2 &#125; &#125;, methods:&#123; next()&#123; if(this.clickdelay)&#123; return &#125; this.clickdelay=true if(this.index==this.originalData.num)&#123; this.index=1 &#125;else&#123; this.index+=1 &#125; this.animate(this.originalData.img_width) &#125;, prev()&#123; if(this.clickdelay)&#123; return &#125; this.clickdelay=true if(this.index==1)&#123; this.index=this.originalData.num &#125;else&#123; this.index-=1 &#125; this.animate(-this.originalData.img_width) &#125;, animate(offset)&#123; var node=this.$refs.wrapperContent var self=this; var left=parseInt(node.style.left)-offset this.isTrans=true node.style.left=left+&apos;px&apos; setTimeout(function()&#123; if(left&lt;-(self.originalData.num*self.originalData.img_width))&#123; self.isTrans=false node.style.left=-self.originalData.img_width+&apos;px&apos; self.clickdelay=false //当到达最后一张图片时 &#125; if(left&gt;-100)&#123; self.isTrans=false node.style.left=-self.originalData.num*self.originalData.img_width+&apos;px&apos; self.clickdelay=false //当到达第一张图片时 &#125; &#125;,this.originalData.delay) &#125;, play()&#123; var self=this; this.timer=setInterval(function()&#123; self.next() &#125;,2000) &#125;, stop()&#123; this.clickdelay=false//用来防止连续点击 clearInterval(this.timer) this.timer=null &#125;, turnTo(flag)&#123; if(flag==this.index)&#123; return &#125;else&#123; var offset=(flag-this.index)*this.originalData.img_width this.index=flag this.animate(offset) &#125; &#125; &#125;, mounted()&#123; /*下面是判断过渡动画是否完成*/ var node=this.$refs.wrapperContent var transitions = &#123; &apos;transition&apos;:&apos;transitionend&apos;, &apos;OTransition&apos;:&apos;oTransitionEnd&apos;, &apos;MozTransition&apos;:&apos;transitionend&apos;, &apos;WebkitTransition&apos;:&apos;webkitTransitionEnd&apos; &#125; var self=this for(var t in transitions)&#123; if( node.style[t] !== undefined )&#123; var transitionEvent=transitions[t]; &#125; &#125; transitionEvent &amp;&amp; node.addEventListener(transitionEvent, function() &#123; self.clickdelay=false &#125;); this.play() &#125;, created()&#123; this.$store.dispatch(&apos;changeShow&apos;,&apos;home&apos;) &#125; &#125; Shop.vue1234567891011121314 methods:&#123; changeLike(index)&#123; this.$store.dispatch(&apos;changeLike&apos;,index)//改变是否喜欢 &#125;, changeFlagTrue(index)&#123; this.$store.dispatch(&apos;changeFlagTrue&apos;,index)//改变是否显示喜欢 &#125;, changeFlagFalse(index)&#123; this.$store.dispatch(&apos;changeFlagFalse&apos;,index)//改变是否显示喜欢 &#125;, changeSelectedItem(index)&#123; this.$store.dispatch(&apos;changeSelectedItem&apos;,index)//改变进入商品 &#125;&#125; 每个商品被点击时都要改变进入的是哪个商品，changeSelectedItem来完成，这个页面想法来源于1626潮牌网，觉得挺好看的，于是自己写了下来，尤其是mouseover显示的是否喜欢，处理的还是可以，不过chrome和Firefox还是会有闪烁的效果没有处理好 shoppingitem.vue这个组件中重要的就是数量的增减，因为每个商品都有一个对象存储数据，并且加入购物车还需要判断购物车中是否有相同信息的商品，还有点击加入购物车后直接跳转到购物车页面，方法如下123456789101112131415161718192021222324 methods:&#123; changeSize(index)&#123; this.$store.dispatch(&apos;changeSize&apos;,index) &#125;, changeColor(num)&#123; this.$store.dispatch(&apos;changeColor&apos;,num) &#125;, changeNumSub()&#123; if(this.item.num&gt;1)&#123; this.$store.dispatch(&apos;changeNumSub&apos;) &#125; &#125;, changeNumAdd()&#123; if(this.item.num&lt;8)&#123; this.$store.dispatch(&apos;changeNumAdd&apos;) &#125; &#125;, addToCart()&#123; if(!!this.item.color&amp;&amp;!!this.item.size)&#123; this.$store.dispatch(&apos;addToCart&apos;) &#125; &#125;&#125; index.js中的方法如下1234567891011121314151617181920212223242526272829ADD_TO_CART(state)&#123; var cart=state.cart; var thing=mutations.clone(state.selectedItem); //查看购物车是否已经有相同的商品，信息都一样 if(!cart.length)&#123; cart.push(thing) &#125;else&#123; var flag=cart.some(function(e)&#123; return e.color==thing.color&amp;&amp;e.size==thing.size&amp;&amp;e.src==thing.src &#125;) try&#123; if(!flag)&#123; cart.push(thing); throw new Error(&quot;can&apos;t find&quot;) &#125; cart.forEach(function(e,index)&#123; if(e.color==thing.color&amp;&amp;e.size==thing.size&amp;&amp;e.src==thing.src)&#123; cart[index].num+=thing.num; foreach.break=new Error(&quot;StopIteration&quot;); &#125; &#125;) &#125;catch(e)&#123; //用于跳出循环 &#125; &#125; state.selectedItem=&#123;&#125;; &#125;, 添加到购物车中的方法中，我用try，catch来跳出forEach循环，还有这句state.selectedItem={};如果state.selectedItem是直接引用别的对象，那么另一个对象也会跟着改变，为了避免引用，我用了如下方法 123456789101112//js复制对象 clone(myObj)&#123; if(typeof(myObj) != &apos;object&apos;) return myObj; if(myObj == null) return myObj; var myNewObj = new Object(); for(var i in myObj) myNewObj[i] = mutations.clone(myObj[i]); return myNewObj; &#125;, Brands.vue 在created(){}中用this.$route.params.id来得到进入那个路由,因为这四个brand布局样式什么的大致都一样，然后watch来检测this.$route.params.id的改变，以此来getIntro也就是每个brand的数据 组件的介绍大致就是这些 四、Vuex我在vuex这里没有做好，状态和数据应该分开，而且actions，mutations，getters，state，应该分开，不然太冗余了 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。这个状态自管理应用包含以下几个部分：state，驱动应用的数据源；view，以声明方式将state映射到视图；actions，响应在view上的用户输入导致的状态变化。 index.js中的state大概罗列一点123456789101112131415161718const state=&#123; loginway:&apos;&apos;, show:&apos;home&apos;, clientheight:0, clientwidth:0, footItems:[ &#123;title:&apos;ABOUT US&apos;,contents:&#123;content_1:&apos;contact us&apos;,content_2:&apos;about vogue&apos;&#125;&#125;, &#123;title:&apos;SERVICE&apos;,contents:&#123;content_1:&apos;payment methods&apos;,content_2:&apos;track order&apos;&#125;&#125;, &#123;title:&apos;POLICY&apos;,contents:&#123;content_1:&apos;privacy policy&apos;,content_2:&apos;terms &amp; condition&apos;&#125;&#125;, &#123;title:&apos;FOLLOW US&apos;,contents:&#123;content_1:&apos;Facebook&apos;,content_2:&apos;Instagram&apos;&#125;&#125;, ], left_nav:&#123; home:&apos;home&apos;, news:&apos;news&apos;, collections:&apos;collections&apos;, shop:&apos;shop&apos; &#125;,] index.js中的mutations1234567891011121314151617181920const mutations=&#123; CHANGE_HW(state,obj)&#123; state.clientwidth=obj.w; state.clientheight=obj.h; &#125;, CHANGE_SHOW(state,type)&#123; state.show=type &#125;, CHANGE_NOWBRAND(state,type)&#123; state.nowbrand=type+&apos;Intro&apos; &#125;, CHANGE_LIKE(state,index)&#123; state.goods[index].isLike=!state.goods[index].isLike; if(!state.goods[index].isLike)&#123; state.goods[index].likes+=1 &#125;else&#123; state.goods[index].likes-=1 &#125; &#125;,&#125; 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： index.js中的actions1234567891011121314const actions=&#123; change_hw(&#123;commit&#125;,obj)&#123; commit(&apos;CHANGE_HW&apos;,obj) &#125;, changeShow(&#123;commit&#125;,type)&#123; commit(&apos;CHANGE_SHOW&apos;,type) &#125;, changeNowbrand(&#123;commit&#125;,type)&#123; commit(&apos;CHANGE_NOWBRAND&apos;,type) &#125;, changeLike(&#123;commit&#125;,index)&#123; commit(&apos;CHANGE_LIKE&apos;,index) &#125;,&#125; Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 index.js中的getters1234567891011121314151617const getters=&#123; getHW:function(state)&#123; return &#123; h:state.clientheight, w:state.clientwidth &#125; &#125;, getBrands:function(state)&#123; return state.brandsArr &#125;, getLeft_nav:function(state)&#123; return state.left_nav &#125;, getShow:function(state)&#123; return state.show &#125;&#125; 有时候我们需要从 store 中的 state 中派生出一些状态,或用于得到信息 五、总结自己写的这个项目，蛮有收获的，遇到了问题到处问，都解决的差不多了，下面罗列了一些收货和本项目的不足 Firefox中不支持 table 的 min-height CSS 的话 考虑用 normalize.css解决不同浏览器初始样式不一样的问题 css 的命名啥的可以参考一下 BEM 的命名规范 代码组织有点杂乱 vuex只要专心做页面状态管理，尽量不要掺杂页面数据 &lt;input type=&quot;checkbox&quot; @change=&quot;selectAll&quot; id=&quot;selectAll&quot; v-model=&quot;isAll&quot;/&gt;此处的isAll是从state中get到得数据，可以被改变，我自己尝试得到的这个结论 轮播还需要改进 第一次在gh-pages中显示时，发现图片加载太慢 ，于是我把图片压缩了 在用git上传代码是出过差错，解决了。 最后感谢您能阅读到这里，本人小白，努力学习中，献丑了。 参考资料 Vue2.0中文文档：https://cn.vuejs.org/ Vue-router2.0中文文档：http://router.vuejs.org/zh-cn/essentials/getting-started.html Vuex2.0中文文档：http://router.vuejs.org/zh-cn/essentials/getting-started.html git教程：http://www.liaoxuefeng.com/]]></content>
    </entry>

    
  
  
</search>
