<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[框架对比]]></title>
      <url>%2F2017%2F04%2F04%2F%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94%2F</url>
      <content type="text"><![CDATA[vue.js 最低支持到ie9 vue.js是一个渐进式框架，自底向上增量开发 任意应用界面都可以抽象成组件树 vue在背后做了很多工作，数据和dom是绑定的，一切都是响应的 vue把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。 变化检测：Vue 会在初始化实例时对属性执行 getter/setter 转化过程 Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。 父子组件的关系可以总结为 props down, events up vue和react相似之处： 使用virtual dom深度剖析virtual dom 提供了响应式和组件化的视图组件 将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。分歧： vue在dom操作上尽可能少的添加额外性能的开销 vue的组件会在渲染过程中自动追踪 html&amp;css在react中都是由JavaScript来写的，所有的组件渲染依靠jsx。优势：可以用完全用JavaScript来构造视图。而vue是拥抱html和css的 vue使用scoped来实现单文件组件css,react使用css modelsvue和angular1 vue的api设计更加简单 vue使用webpack template模块化，更灵活 angular1用的是双向绑定，而vue在不同组件中强制单向数据流 vue中指令和组件分的很清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 有自己的视图和数据逻辑。 在angular1中随着watcher越来越多，会导致变慢，并且如果一个watcher触发另一个更新，脏检查会执行多次。而vue是基于依赖追踪的观察系统而且异步更新队列angular2 面向大型企业应用 typescript]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[想说]]></title>
      <url>%2F2017%2F04%2F03%2Fdaily1%2F</url>
      <content type="text"><![CDATA[折腾hexo两天了，让我对那些牛逼的人又心生崇拜了然而还有些功能没加，又丑又慢，下面进入正题 3月结束了，过得好累啊3月，但4月会更累。。。学校里的樱花都开了，浪多berber嬢嬢些都在照相。一同学都和女朋友跑武大去看樱花咯。而我们。。。前面那女生还是同学的朋友来坐一下。活得不累，活的gay啊！3月中旬投了一个成都的小公司，结果被面得我毫无自信了。然后就看面经，看计网，看数据结构，可是还是好差。。。网申了几家公司，但笔试好坑好坑，估计一家都不得给面试。（怀疑人生中） 但我觉得现在得生活好充实，忙碌吧但又自由，最主要是有几个志同道合的同学，生活还是比高三那会舒服。不知不觉还是快要高考了，又想到那个不知天高地厚的自己，觉得最差也要考个川大，结果啪啪啪打脸了吧但现在觉得还是不咋个。当初也不造咋选了计算机，可能觉得高大上吧。结果进学校就被c语言弄的怀疑人生。感觉什么都不懂更懵逼的是当时一个班学长说来辅导我们高数啊什么的，他说我们有问题就去二教五楼找他，他随时在那儿。当时我就觉得，握草，这学长这么牛批，换我怎么也做不到，都不打游戏吗，结果我现在就是他那样了?我就是因为刚开始太闲了，要不就是睡觉，最后无奈玩上了游戏，一玩就不得了了，沉浸于自我无法自拔，比照镜子还有成就感。但我觉得那会游戏维持了我跟高中兄弟的联系，大学同学也赞同我说法。现在不玩了，兄弟就都在心中了，因为大家都开始忙了，等回家了再一醉方休。讲真好久没有跟熟识的人聊天了。不知道他们过得咋样呢。不过我晓得他们背单词牛批的很，100多天的打卡。我这学期刚开始也在打，结果最多一周。和寝室考研的兄弟伙些一样，他们也只坚持了1周的早起。 有点困咯，晕乎乎你以为要结束了，no 今天是我爸的生日 不对是昨天，3号生日快乐啊爸爸，好久没陪爸爸过生日了。惭愧至极。我也不造为什么我本来能说个不停的人，在家人面前就始终说不出来，从小到大都这样，是不是要看哈心里医生啊。好久没有和爸爸合照了，突然好想家人啊。这学期过了我要常回家了，感觉家乡的人都觉得我消失了一样。每次三姑六婆都在说自己孩子怎么的时候，我想爸妈一定会有失落吧，“俊杰总不喜欢和我们分享自己的事”。但是我也不是不喜欢，怎么说呢，从小到大都是这样，已经习惯了，难过的事不会告诉他们，高兴的事也偶尔告诉他们。我真的，不管今后再外面闯的什么个层次，我心里永远都觉得自己是失败的。我做的不好，我也不知道怎么做好。照片是08年的时候吧好像，我妈弄在微信里发给我的，那时候笑的好灿烂，但这分钟我哭了。。 我爱你们愿望 家人平安健康]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[居中]]></title>
      <url>%2F2017%2F03%2F07%2F%E5%B1%85%E4%B8%AD%2F</url>
      <content type="text"><![CDATA[方法一：运用flex布局 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .app&#123;width: 500px;height: 500px;background: green;&#125; .app&#123;display: flex;align-items: center;justify-content: center&#125; /*这样用text-align无用，布局以后，子元素的float、clear和vertical-align属性将失效。*/ .app img&#123;width: 200px;height: 200px&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class='app'&gt; &lt;img src="img/bg.jpg" alt="img" title="img"/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方法二：也是运用flex布局，不过这次是在子元素用align-self：center 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .app&#123;width: 500px;height: 500px;background: green;&#125; .app&#123;display: flex;justify-content: center&#125; .app img&#123;align-self: center&#125; .app img&#123;width: 200px;height: 200px&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class='app'&gt; &lt;img src="img/bg.jpg" alt="img" title="img"/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方法一和方法二的效果如图：方法三：如果在一段块元素包裹的行内元素中有某个元素比较特殊, 比如: 大写加粗的文字 、 乱入的图片图标, 垂直居中: 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .text&#123;width: 500px;height: 500px;background: red;&#125; .text img&#123; width: 200px;height: 200px;vertical-align: middle;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="text"&gt; &lt;img src="img/bg.jpg" alt="img" title="img"/&gt;可以的 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果： 方法四：父元素相对定位(或其他定位){ position: relative; }子元素绝对定位{ position: absolute; top: 0; left: 0; bottom: 0; right: 0; margin: auto }1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .outer&#123;width: 400px;height: 400px;background: pink;position: relative;&#125; .inner&#123;width: 200px;height: 200px;background: black;position: absolute;left: 0;bottom: 0;top: 0;right: 0;margin: auto&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="outer"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果：方法五：用padding方法六：height/line-height设为相同值方法七：父元素设置{ display: table-cell; vertical-align: middle; } 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .app&#123;width: 500px;height: 500px;background: green;&#125; .app&#123;display: table-cell;vertical-align: middle;text-align: center&#125; .app img&#123;width: 200px;height: 200px&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class='app'&gt; &lt;img src="img/bg.jpg" alt="img" title="img"/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果：方法八：父元素：position：relative中间元素：position：absolute；left：50%；top：50%子元素：position：absolute；left：-50%；top：-50% 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .container&#123;width: 400px;height: 400px;position: relative;background: pink&#125; .box&#123;position: absolute;left:50%;top:50%;width: 200px;height: 200px&#125; .boxinner&#123;width: 200px;height: 200px;position: relative;left: -50%;top:-50%;background: black&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="box"&gt; &lt;div class="boxinner"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果：方法九：父元素：position：relative子元素：position：absolute；（transform: translate: (-50%, 50%) ）或者（margin-left：-xxpx；margin-top：-xxpx）top：50%；left：50%1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .outer&#123;width: 400px;height: 400px;background: pink;position: relative;&#125; .inner&#123;width: 200px;height: 200px;position: absolute;margin-left: -100px;margin-top: -100px;left: 50%;top: 50%;background: black&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="outer"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果：方法十利用伪元素 1234567.main&#123;width: 400px;height: 400px;background: green;text-align: center&#125;.main:after&#123;content: '';display: inline-block;width: 0;height: 100%;vertical-align: middle;overflow: hidden;&#125;.inner&#123;width: 100px;height: 100px;background: pink;vertical-align: middle;display: inline-block;&#125;&lt;div class="main"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt; 方案十一： 1234567多行文本居中&lt;div style="width:150px;height:100px;line-height:100px;background-color:#ccc;font-size:0;"&gt; &lt;span style="display:inline-block;font-size:10px;line-height:1.4em;vertical-align:middle;"&gt;This is a test.&lt;br/&gt; This is a test. &lt;/span&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面经学习]]></title>
      <url>%2F2017%2F03%2F07%2F%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[url回车后发生了什么域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？（1）行内元素有：a b span img input select strong（强调的语气）（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p（3）常见的空元素：12&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 鲜为人知的是： 12&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 页面可见性（Page Visibility API） 可以有哪些用途？通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放； 权重计算规则第一等：代表内联样式，如: style=””，权值为1000。第二等：代表ID选择器，如：#content，权值为0100。第三等：代表类，伪类和属性选择器，如.content，权值为0010。第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。继承的样式没有权值。 多列等高align-item:stretch12345678.container&#123;margin: 0 auto;width: 600x;border: 3px solid #00c;overflow: hidden;&#125;.left&#123;float: left;width: 150px;background: #b0b0b0;padding-bottom: 100px;margin-bottom: -100px;&#125;.right&#123;float: left;width: 450px;background: #6cc;padding-bottom: 100px;margin-bottom: -100px;&#125;&lt;div class="container"&gt; &lt;div class="left"&gt;ssss&lt;/div&gt; &lt;div class="right"&gt;ssss&lt;br&gt;&lt;br/&gt;&lt;br/&gt;dfdkjij&lt;/div&gt;&lt;/div&gt; li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。 123456789101112&lt;style type="text/css"&gt; ul&#123;list-style-type: none;font-size: 0;padding: 0;margin: 0&#125; li&#123;width: 50px;height: 50px;background: red;display: inline-block;font-size: 12px;vertical-align: top&#125; &lt;ul&gt; &lt;li&gt;sss&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;dd&lt;/li&gt; &lt;li&gt;gg&lt;/li&gt; &lt;li&gt;gg&lt;/li&gt; &lt;/ul&gt;&lt;/style&gt; 一个元素的 containing block 按以下方式定义： 用户代理（比如浏览器）选择根元素作为 containing block（称之为初始 containing block）。 对于其它元素，除非元素使用的是绝对位置，containing block 由最近的块级祖先元素盒子的内容边界组成。 如果元素有属性 ‘position:fixed’，containing block 由视口建立。 如果元素有属性 ‘position:absolute’，containing block 由最近的 position 不是 static 的祖先建立，按下面的步骤： 如果祖先是块级元素，containing block 由祖先的 padding edge 形成。 如果祖先是内联元素，containing block 取决于祖先的 direction 属性。 如果 direction 是 ltr（左到右），祖先产生的第一个盒子的上、左内容边界是 containing block 的上方和左方，祖先的最后一个盒子的下、右内容边界是 containing block 的下方和右方。 如果 direction 是 rtl（右到左），祖先产生的第一个盒子的上、右内容边界是 containing block 的上方和右方，祖先的最后一个盒子的下、左内容边界是 containing block 的下方和左方。 如果没有祖先，根元素盒子的内容边界确定为 containing block。 visibility的collapse当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 “hidden”。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组操作]]></title>
      <url>%2F2017%2F03%2F06%2F%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[1234567891011function unique1(array)&#123; var n = []; //一个新的临时数组 //遍历当前数组 for(var i = 0; i &lt; array.length; i++)&#123; //如果当前数组的第i已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (n.indexOf(array[i]) == -1) n.push(array[i]); &#125; return n; &#125; 循环遍历嵌套数组1234567891011121314151617181920212223242526function getArray(arr)&#123; var arrs=[]; for(var i=0;i&lt;arr.length;i++)&#123; if(!Array.isArray(arr[i]))&#123; arrs.push(arr[i]) &#125;else&#123; arrs=arrs.concat(getArray(arr[i])) &#125; &#125; return arrs&#125;//法二var arr=[1,[2,[5,6],&#123;value:&apos;ddd&apos;&#125;],4],result=[]function getArray(arr,result)&#123; var temp; for(var i=0;i&lt;arr.length;i++)&#123; temp=arr[i] if(Array.isArray(temp))&#123; getArray(temp,result) &#125;else&#123; result.push(temp) &#125; &#125;&#125;getArray(arr,result) 对象克隆12345678910111213141516function clone(Obj) &#123; var buf; if (Obj instanceof Array) &#123; buf=Array.prototype.slice.call(Obj) return buf; &#125; else if (Obj instanceof Object)&#123; buf = &#123;&#125;; // 创建一个空对象 for (var k in Obj) &#123; // 为这个对象添加新的属性 buf[k] = clone(Obj[k]); &#125; return buf; &#125;else&#123; return Obj; &#125;&#125; 深度克隆 123456789101112131415161718192021222324function deepClone(obj)&#123; var _toString=Object.prototype.toString; if(!obj||typeof obj!==&apos;object&apos;)&#123; return obj; &#125; if(obj.nodeType&amp;&amp;&apos;clone&apos; in obj)&#123; return obj.cloneNode(true) &#125; if(_toString.call(obj)===&apos;[object Date]&apos;)&#123; return new Date(obj.getTime()) &#125; if(_toString.call(obj)===&apos;[object RegExp]&apos;)&#123; var flags=[]; if(obj.global)&#123;flags.push(&apos;g&apos;)&#125; if(obj.multiline)&#123;flags.push(&apos;m&apos;)&#125; if(obj.ignoreCase)&#123;flags.push(&apos;i&apos;)&#125; return new RegExp(obj.source,flags.join(&apos;&apos;)) &#125; var result=Array.isArray(obj)?[]:obj.constructor?new obj.constructor():&#123;&#125; for(var key in obj)&#123; result[key]=deepClone(obj[key]); &#125; return result;&#125; 求数组最大数 1Math.max.apply(null,arr)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[封装函数]]></title>
      <url>%2F2017%2F03%2F06%2F%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[近期看的数据结构貌似呼还是挺有用的然而还是会忘记123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211//栈function Stack() &#123; var items = []; this.push = function (element) &#123; items.push(element); &#125;;//推栈 this.pop = function () &#123; return items.pop(); &#125;;//弹栈 this.peek = function () &#123; return items[items.length - 1]; &#125;;//栈顶元素 this.isEmpty = function () &#123; return items.length === 0; &#125;;//栈是否为空 this.size = function () &#123; return items.length; &#125;;//栈大小 this.clear = function () &#123; items = []; &#125;;//清空栈 this.print = function () &#123; console.log(items.toString()); &#125;;//打印栈&#125;//队列function Queue() &#123; var items = []; this.enqueue = function (element) &#123; items.push(element); &#125;//入队 this.dequeue = function () &#123; return items.shift(); &#125;//出队 this.front = function () &#123; return items[0]; &#125;//队首元素 this.isEmpty = function () &#123; return items.length === 0; &#125;//队列是否为空 this.clear = function () &#123; items = []; &#125;//清空队列 this.size = function () &#123; return items.length; &#125;//队列大小 this.print = function () &#123; console.log(items.toString()); &#125;//打印队列&#125;//圣杯继承var inherit = (function ()&#123; var F = function () &#123;&#125;; return function (Child, Parent) &#123; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.prototype.uber = Parent.prototype; &#125;&#125;)();//深层拷贝对象（不考虑函数）function deepClone(original, target) &#123; var target = target || &#123;&#125;, toStr = Object.prototype.toString, arrStr = '[object Array]'; for(var prop in original)&#123; if(original.hasOwnProperty(prop))&#123; if(typeof original[prop] === 'object')&#123; target[prop] = (toStr.call(original[prop]) === arrStr) ? [] : &#123;&#125;; deepClone(original[prop], target[prop]); &#125;else&#123; target[prop] = original[prop]; &#125; &#125; &#125; return target;&#125;//数组去重Array.prototype.unique = function() &#123; var obj = &#123;&#125;, arr = [], len = this.length; for(var i = 0; i &lt; len; i++)&#123; if(!obj[this[i]])&#123; obj[this[i]] = true; arr.push(this[i]); &#125; &#125; return arr;&#125;//类属性function classOf(o)&#123; if(o === null) return "Null"; if(o === undefined) return "Undefined"; return Object.prototype.toString.call(o).slice(8,-1);&#125;//父节点的第几个元素节点Element.prototype.eleIndex = function()&#123; var index = 0, node = this; while(node = node.previousSibling)&#123; if(node.nodeType == 1)&#123; index++; &#125; &#125; return index;&#125;//第n层祖先元素Element.prototype.nthParentEle = function(n) &#123; var node = this, n = n || 0; while(node &amp;&amp; n--) &#123; node = node.parentElement; &#125; return node;&#125;//第n个兄弟节点Element.prototype.nthSiblingEle = function(n)&#123; var node = this; while(node &amp;&amp; n) &#123; if(n &gt; 0)&#123; if(node.nextElementSibling)&#123; node = node.nextElementSibling; &#125;else&#123; for(node = node.nextSibling; node &amp;&amp; node.nodeType !== 1; node = node.nextSibling); &#125; n--; &#125;else&#123; if(node.previousElementSibling)&#123; node = node.previousElementSibling; &#125;else&#123; for(node = node.previousSibling; node &amp;&amp; node.nodeType !== 1; node = node.previousSibling); &#125; n++; &#125; &#125; return node;&#125;//在某元素后插入元素Element.prototype.insertAfter = function (targetNode, afterNode)&#123; var siblingNode = afterNode.nextElementSibling; if(siblingNode) &#123; this.insertBefore(targetNode,siblingNode); &#125; else &#123; this.appendChild(targetNode); &#125; return targetNode;&#125;//销毁元素节点自身Element.prototype.remove = function ()&#123; this.parentElement.removeChild(this);&#125;//目标节点内部的节点顺序逆序Element.prototype.revChild = function ()&#123; var child = this.children, len = child.length; for (var i = len - 2; i &gt;= 0; i--)&#123; this.appendChild(child[i]); &#125; return this;&#125;//查看滚动轮滚动距离function getScrollOffset()&#123; if(window.pageXOffset)&#123; return &#123; x: window.pageXOffset, y: window.pageYOffset &#125; &#125;else&#123; return &#123; x: document.body.scrollLeft + document.documentElement.scrollLeft, y: document.body.scrollTop + document.documentElement.scrollTop &#125; &#125;&#125;//查看浏览器视口尺寸function getViewportOffset()&#123; if(window.innerWidth)&#123; return &#123; w: window.innerWidth, h: window.innerHeight &#125; &#125;else if(document.compatMode === "CSS1Compat")&#123; return&#123; w: document.documentElement.clientWidth, h: document.documentElement.clientHeight &#125; &#125;else&#123; return&#123; w: document.body.clientWidth, h: document.body.clientHeight &#125; &#125;&#125;//求元素相对于文档的坐标Element.prototype.getCoord = function ()&#123; var coordX = 0, coordY = 0, docEle = this; while(docEle)&#123; coordX += docEle.offsetLeft; coordY += docEle.offsetTop; docEle = docEle.offsetParent; &#125; return &#123; x: coordX, y: coordY &#125;&#125;; 123//获取相对文档的距离var X= this.getBoundingClientRect().left+document.documentElement.scrollLeft; var Y =this.getBoundingClientRect().top+document.documentElement.scrollTop; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147//获取样式function getStyle(ele, style)&#123; if(window.getComputedStyle)&#123; return window.getComputedStyle(ele,null)[style]; &#125;else&#123; return ele.currentStyle[style]; &#125;&#125;//添加事件function addEvent(elem, type, handler)&#123; if(elem.addEventListener)&#123; elem.addEventListener(type, handler, false); &#125;else if(elem.attachEvent)&#123; elem[&apos;temp&apos; + type + handler] = handler; elem[&apos;temp&apos; + type] = function()&#123; elem[&apos;temp&apos; + type + handler].call(elem); &#125; elem.attachEvent(&apos;on&apos; + type, elem[&apos;temp&apos; + type]); &#125;else&#123; elem[&apos;on&apos; + type] = handler; &#125;&#125;//解除事件function removeEvent(elem, type, handler)&#123; if(elem.removeEventListener)&#123; elem.removeEventListener(type, handler, false); &#125;else if(elem.detachEvent)&#123; elem.detachEvent(&apos;on&apos; + type, elem[&apos;temp&apos; + type]); &#125;else&#123; elem[&apos;on&apos; + type] = null; &#125;&#125;//取消冒泡function stopBubble(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125;&#125;//阻止默认事件function cancelHandler(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125;&#125;//拖拽元素function drag(elem)&#123; var disX; var disY; addEvent(elem,&quot;mousedown&quot;,function(e)&#123; var event = e || window.event; disX = event.clientX - parseInt(getStyle(this,&quot;left&quot;)); disY = event.clientY - parseInt(getStyle(this,&quot;top&quot;)); addEvent(document,&quot;mousemove&quot;,mouseMove); addEvent(document,&quot;mouseup&quot;,mouseUp); &#125;); function mouseMove(e)&#123; var event = e || window.event; elem.style.left = event.pageX - disX + &apos;px&apos;; elem.style.top = event.pageY - disY + &apos;px&apos;; &#125; function mouseUp()&#123; removeEvent(document,&quot;mousemove&quot;,mouseMove); removeEvent(document,&quot;mouseup&quot;,mouseUp); &#125;&#125;//多物体多值链式运动框架function startMove(elem, json, func)&#123; clearInterval(elem.timer); var iSpeed; var iCur; var bStop; elem.timer = setInterval(function()&#123; bStop = true; for(var attr in json)&#123; iCur = attr === &apos;opacity&apos; ? parseFloat(getStyle(elem,attr)) * 100 : parseInt(getStyle(elem,attr)); iSpeed = attr === &apos;opacity&apos; ? (parseFloat(json[attr])* 100 - iCur) / 7 : (parseInt(json[attr]) - iCur) / 7; iSpeed = iSpeed &gt; 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed); elem.style[attr] = attr === &quot;opacity&quot; ? (iCur + iSpeed) / 100 : iCur + iSpeed + &apos;px&apos;; if(iCur !== (attr === &apos;opacity&apos; ? parseFloat(json[attr]) * 100 : parseInt(json[attr])))&#123; bStop = false; &#125; &#125; if(bStop)&#123; clearInterval(elem.timer); if(func)&#123; func(); &#125; &#125; &#125;,30);&#125;//按需异步加载scriptfunction scriptLoaded(url, callback)&#123; var script = document.createElement(&apos;script&apos;); script.type = &quot;text/javascript&quot;; if(script.readyState)&#123; script.onreadystatechange = function()&#123; if(script.readyState == &quot;complete&quot; || script.readyState == &quot;loaded&quot;)&#123; callback(); script.onreadystatechange = null; &#125; &#125; &#125;else&#123; script.onload = function()&#123; script.onload = null; callback(); &#125; &#125; script.src = url; document.head.appendChild(script);&#125;//兼容getElementByClassNameDocument.prototype.getByClassName = function(target) &#123; var allEle = document.getElementsByTagName(&apos;*&apos;), len = allEle.length, arr = [], classArr = [], classArrLen; for(var i = 0; i &lt; len; i++) &#123; classArr = allEle[i].className.myTrim().splice(&apos; &apos;); classArrLen = classArr.length; for(var j = 0; j &lt; classArrLen; j++)&#123; if(classArr[j] === target)&#123; arr.push(allEle[i]); break; &#125; &#125; &#125; return arr;&#125;//兼容trimString.prototype.myTrim = function() &#123; var reg = /^\s*|\s*$/; return this.replace(reg,&apos;&apos;);&#125;String.prototype.trim=function()&#123; return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);&#125;String.prototype.ltrim=function()&#123; return this.replace(/(^\s*)/g,&quot;&quot;);&#125;String.prototype.rtrim=function()&#123; return this.replace(/(\s*$)/g,&quot;&quot;);&#125; 123456789101112//共享onload事件function addLoadEvent(func)&#123; var oldLoad=window.onload if(typeof window.onload!=&apos;function&apos;)&#123; window.onload=func &#125;else&#123; window.onload=function()&#123; oldLoad() func() &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[某公司面试]]></title>
      <url>%2F2017%2F03%2F06%2F%E6%9F%90%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%2F</url>
      <content type="text"><![CDATA[sessionstorage、localstorage、cookie区别 cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie **存储大小：** cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 seessionStorage 临时性的，页面打开有，页面关闭没有 数据不共享 通过a标签来跳出一个页面，则sessionStorage共享 localStorage 永久性的存储 不能跨域 数据共享 cookiecookie在同源且符合path规则的文档之间共享 如何实现浏览器内多个标签页之间的通信? WebSocket、SharedWorker； 也可以调用localstorge、cookies等本地存储方式； localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件， 我们通过监听事件，控制它的值来进行页面信息通信； 注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常； 懒加载和预加载 用CSS和JavaScript实现预加载:backgrond 仅使用JavaScript实现预加载 使用Ajax实现预加载 第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟. 第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。 第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。 post和get的区别 正则表达式 bfc如何触发 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible 快速排序和堆排序 盒子模型与box-sizing 翻墙 css和js引入位置浏览器解析html页面首先浏览器先下载html，然后在内存中把html代码转化成Dom Tree，然后浏览器根据Dom Tree上的Node分析css和Images，当文档下载遇到js时，js独立下载。js是阻塞加载，会影响页面加载的速度，如果js文件比较大，算法也比较复杂的话，影响更大。CSS放在前端是页面渲染时首先是根据DOM结构生成一个DOM树然后加上CSS样式生成一个渲染树，如果CSS放在后面可能页面会出现闪跳的感觉，或者是白屏或者布局混乱样式很丑直到CSS加载完成。 rem和em 登录安全性 hashtag和history 画三角形 长连接短连接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2017%2F03%2F05%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[用处： 测试字符串内的模式。例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。可以查找文档内或输入域内特定的文本。 如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。同时，可以通过正则对象的lastIndex属性指定开始搜索的位置。 123456789101112131415var xReg = /x/g;var str = &apos;xyz_x1_y1_x3&apos;;xReg.lastIndex; // 0xReg.test(str); // truexReg.lastIndex; // 1xReg.test(str); // truexReg.lastIndex; // 5// 指定位置开始 指定下次匹配从最后一位开始，就匹配不到了xReg.lastIndex = 11; // 11xReg.test(str); // falsexReg.lastIndex; // 0 实践： 1var indexReg = /^(?:http|https).+\/jwebui\/pages\/themes\/(\w+)\/\1\.jspx(\?\S+)?$/i ; 最开始的^ 和最后的$分别表示匹配的开始和结束。 (?:http|https)表示两者之一，这么写是非获取的组匹配，()不会被分组存储。也可以写成(http|https) 但是后面的\1就需要替换成\2了，因为这么写时此处形成了第一个分组。 .+ 就是任意字符至少出现一次。 \/jwebui\/pages\/themes\/ 就是匹配字符串”/jwebui/pages/themes/“。 (\w+) 作为第一个分组，表示任意字母或数字或下划线或汉字至少出现一次。 \1表示对第一个分组的引用，再重复第一分组的内容 。 .jspx 表示.jspx。 (\?\S+)? 表示(\?\S+) 匹配的内容出现0次或一次。其中:\? 表示？ 。\S+ 表示任意可见字符出现至少一次。将字符串转换为驼峰表示法 123456function toCampStyle(str)&#123; var reg=/-([a-z]+)/ig; return str.replace(reg,function(all,letter)&#123; return letter.slice(0,1).toUpperCase()+letter.slice(1) &#125;)&#125; 检测有无重复字母 123var reg=/([a-zA-Z])\1/g;var str=&apos;aadididi&apos;console.log(reg.test(str)) 实现千分位分隔符 1234function format (num) &#123; var reg=/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g; return (num + &apos;&apos;).replace(reg, &apos;$&amp;,&apos;); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[清除浮动]]></title>
      <url>%2F2017%2F03%2F04%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[清除浮动的方法可以分成两类： 一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。 二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素 父级div定义 height 原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 优点：简单、代码少、容易掌握 缺点：：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 结尾处加空div标签 clear:both 原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 优点：简单、代码少、浏览器支持好、不容易出现怪问题 缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好 父级div定义 伪类:after 和 zoom .clearfloat:after{display:block;clear:both;content:&quot;&quot;;visibility:hidden;height:0} 原理： IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 优点： 浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点： 代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 父级div定义 overflow:hidden 优点：简单、代码少、浏览器支持好 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 父级div 也一起浮动 缺点：会产生新的浮动问题。 父级div定义 display:table]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue实现无限轮播]]></title>
      <url>%2F2017%2F03%2F03%2Fvue%E8%BD%AE%E6%92%AD%2F</url>
      <content type="text"><![CDATA[思路： 要实现无限轮播，需要在轮播图前后各加一张图片，加在前面的是轮播图的最后一张图片（重复的），加在后面的是轮播图的第一张图片（重复的）。例： 12345678&lt;div class=&quot;wrapper-content&quot;&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; src=&quot;img/4.jpg&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; src=&quot;img/1.jpg&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;2&quot; src=&quot;img/2.jpg&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;3&quot; src=&quot;img/3.jpg&quot; /&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; src=&quot;img/4.jpg&quot; /&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; src=&quot;img/1.jpg&quot; /&gt; &lt;/div&gt; 然后再用left来控制滑动，当顺向到达alt为4的图片时，下一张滑到第六张图片，alt为1，同时改变index为1.然后立即将left移到第二张图片，alt为1那张。这样就不会被察觉 好了，贴代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; *&#123;margin: 0;padding: 0&#125; .wrapper&#123;position: relative;overflow: hidden;&#125; .wrapper-content&#123;position: absolute;left: 0;z-index: 1;&#125; .wrapper-content_img&#123;border: none;outline:none;float: left&#125; .wrapper-buttons&#123;position: absolute;width: 100px;height: 20px;text-align: center;bottom: 3px;z-index: 2;&#125; .wrapper-button&#123;float: left;width: 20px;height: 20px;border-radius: 10px;background: gray;margin: 0 2.5px;cursor: pointer;&#125; .wrapper-arrow&#123;position: absolute;width: 40px;height:40px;cursor: pointer;background-color: RGBA(0,0,0,.3); color: #fff;display: none;top:50%;line-height: 40px;font-size: 36px;text-align: center;z-index: 2;&#125; .wrapper:hover .wrapper-arrow&#123;display: block;background-color: rgba(0,0,0,.7);&#125; .wrapper-prev&#123;left:10px;&#125; .wrapper-next&#123;right:10px;&#125; .wrapper_on&#123;background-color: yellow&#125; .wrapper_trans&#123;transition: left .3s ease&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;wrapper&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot; @mouseover=&quot;stop&quot; @mouseout=&quot;play&quot;&gt; &lt;div class=&quot;wrapper-content&quot; :class=&quot;&#123;wrapper_trans:isTrans&#125;&quot; :style=&quot;&#123;width:originalData.img_width*(originalData.num+2)+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;,left:-originalData.img_width+&apos;px&apos;&#125;&quot; ref=&quot;wrapperContent&quot;&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; src=&quot;img/4.jpg&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; src=&quot;img/1.jpg&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;2&quot; src=&quot;img/2.jpg&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;3&quot; src=&quot;img/3.jpg&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; src=&quot;img/4.jpg&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; src=&quot;img/1.jpg&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;wrapper-buttons&quot; :style=&quot;&#123;left:(originalData.img_width-100)/2+&apos;px&apos;&#125;&quot;&gt; &lt;span :class=&quot;[&apos;wrapper-button&apos;,&#123;&apos;wrapper_on&apos;:index==1&#125;]&quot; @click=&quot;turnTo(1)&quot;&gt;&lt;/span&gt; &lt;span :class=&quot;[&apos;wrapper-button&apos;,&#123;&apos;wrapper_on&apos;:index==2&#125;]&quot; @click=&quot;turnTo(2)&quot;&gt;&lt;/span&gt; &lt;span :class=&quot;[&apos;wrapper-button&apos;,&#123;&apos;wrapper_on&apos;:index==3&#125;]&quot; @click=&quot;turnTo(3)&quot;&gt;&lt;/span&gt; &lt;span :class=&quot;[&apos;wrapper-button&apos;,&#123;&apos;wrapper_on&apos;:index==4&#125;]&quot; @click=&quot;turnTo(4)&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;wrapper-arrow wrapper-prev&quot; :style=&quot;&#123;marginTop:-originalData.btn_width/2+&apos;px&apos;&#125;&quot; @click=&quot;prev&quot;&gt;&amp;lt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;wrapper-arrow wrapper-next&quot; :style=&quot;&#123;marginTop:-originalData.btn_width/2+&apos;px&apos;&#125;&quot; @click=&quot;next&quot;&gt;&amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;a href=&quot;#&quot; style=&quot;width: 50px;height: 50px;position: absolute;top: 500px;&quot;&gt;aaa&lt;/a&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://unpkg.com/vue@2.1.10/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&apos;#app&apos;, data:&#123; originalData:&#123; img_width:350, img_height:350, btn_width:40, btn_height:40, num:4, delay:300 &#125;, isTrans:true,//因为到最后一张图片，index为1时，需要立即跳到第二张index也为1的图片，这个用来是否给出transition index:1, timer:null,//setInterval clickdelay:false//用来防止连续点击 &#125;, methods:&#123; next()&#123; if(this.clickdelay)&#123; return &#125; this.clickdelay=true if(this.index==this.originalData.num)&#123; this.index=1 &#125;else&#123; this.index+=1 &#125; this.animate(this.originalData.img_width) &#125;, prev()&#123; if(this.clickdelay)&#123; return &#125; this.clickdelay=true if(this.index==1)&#123; this.index=this.originalData.num &#125;else&#123; this.index-=1 &#125; this.animate(-this.originalData.img_width) &#125;, animate(offset)&#123; var node=this.$refs.wrapperContent var self=this; var left=parseInt(node.style.left)-offset this.isTrans=true node.style.left=left+&apos;px&apos; setTimeout(function()&#123; if(left&lt;-(self.originalData.num*self.originalData.img_width))&#123; self.isTrans=false node.style.left=-self.originalData.img_width+&apos;px&apos; self.clickdelay=false //当到达最后一张图片时 &#125; if(left&gt;-100)&#123; self.isTrans=false node.style.left=-self.originalData.num*self.originalData.img_width+&apos;px&apos; self.clickdelay=false //当到达第一张图片时 &#125; &#125;,this.originalData.delay) &#125;, play()&#123; var self=this; this.timer=setInterval(function()&#123; self.next() &#125;,2000) &#125;, stop()&#123; this.clickdelay=false//用来防止连续点击 clearInterval(this.timer) this.timer=null &#125;, turnTo(flag)&#123; if(flag==this.index)&#123; return &#125;else&#123; var offset=(flag-this.index)*this.originalData.img_width this.index=flag this.animate(offset) &#125; &#125; &#125;, mounted()&#123; /*下面是判断过渡动画是否完成*/ var node=this.$refs.wrapperContent var transitions = &#123; &apos;transition&apos;:&apos;transitionend&apos;, &apos;OTransition&apos;:&apos;oTransitionEnd&apos;, &apos;MozTransition&apos;:&apos;transitionend&apos;, &apos;WebkitTransition&apos;:&apos;webkitTransitionEnd&apos; &#125; var self=this for(var t in transitions)&#123; if( node.style[t] !== undefined )&#123; var transitionEvent=transitions[t]; &#125; &#125; transitionEvent &amp;&amp; node.addEventListener(transitionEvent, function() &#123; self.clickdelay=false &#125;); this.play() &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 由于是封装的，高度宽度好多写在了内联style里]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[margin坍塌]]></title>
      <url>%2F2017%2F03%2F03%2FmarginNoUse%2F</url>
      <content type="text"><![CDATA[今天在写代码过程中，解决了一个小问题，代码如下。在.first的div中设置margin-top，效果却是和父div设置margin-top一样，网上又搜了答案总结一下 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .main&#123;height: 400px;width: 200px;background: yellow;&#125; .first&#123;width: 100px;height: 100px;background: red;margin-bottom: 50px;margin-top: 100px;margin-right: 0px&#125; .second&#123;width: 100px;height: 100px;background: black;margin-top: 100px&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;first&quot;&gt;&lt;/div&gt; &lt;div class=&quot;second&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 解决办法: 在父层div加上：overflow:hidden； 把margin-top外边距改成padding-top内边距 ； 父元素产生边距重叠的边有不为 0 的 padding 或宽度不为 0 且 style 不为 none 的 border。父层div加： padding-top: 1px;或者border:1px solid black 让父元素生成一个 block formating context，以下属性可以实现 float: left/right position: absolute display: inline-block/table-cell(或其他 table 类型) overflow: hidden/auto父层div加：position: absolute;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cssRule那些事]]></title>
      <url>%2F2017%2F03%2F02%2Fcssrules%2F</url>
      <content type="text"><![CDATA[div.style.cssText返回内联样式，并且可以改变 1234567&lt;style&gt; .main&#123;width: 100px;height: 200px;background: red&#125;&lt;/style&gt;&lt;div class=&quot;main&quot; style=&quot;margin:10px&quot;&gt;&lt;/div&gt;var el=document.querySelector(&apos;.main&apos;)el.style.cssText//margin:10px getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，只读。 用法 ：var style = window.getComputedStyle(“元素”, “伪类”);或者 ：document.defaultView.getComputedStyle(“元素”, “伪类”) 在ie中用currentStyle属性 12var computedStyle=mydiv.currentStyle 操作样式表 document.styleSheets返回StyleSheetList {0: CSSStyleSheet, length: 1} 通过style或者sheet取得CSSStyleSheet 1234var link=document.getElementsByTagName(&apos;link&apos;)[0];function getStyleSheet(element)&#123; return element.sheet||element.styleSheet&#125; css规则 123456789101112131415161718var sheet=document.styleSheets[1];//这个下还有addRule，deleteRule,insertRule(&quot;body&#123;background-color:silver&#125;&quot;,0)等方法var rules=sheet.cssRules||sheet.rules;var rule=rules[0];console.log(rule)///*CSSStyleRule &#123;selectorText: &quot;.main&quot;, style: CSSStyleDeclaration, type: 1, cssText: &quot;.main &#123; width: 100px; height: 200px; background: red; &#125;&quot;, parentRule: null…&#125;cssText:&quot;.main &#123; width: 100px; height: 200px; background: red; &#125;&quot;parentRule:nullparentStyleSheet:CSSStyleSheetselectorText:&quot;.main&quot;style:CSSStyleDeclarationtype:1__proto__:CSSStyleRule*/console.log(rule.style.width)//100px]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用requestAnimationFrame做轮播]]></title>
      <url>%2F2017%2F03%2F01%2Farticle-title%2F</url>
      <content type="text"><![CDATA[用setTimeout和setInterval来实现动画 没有对调用动画的循环机制进行优化 即使传递毫秒为单位的参数，也不能打到ms的准确性。因为JavaScript是单线程的，可能发生阻塞 没有考虑绘制动画的最佳时机 requestAniamationFrame requestAnimationFrame不需要使用者指定循环间隔时间，浏览器会基于当前页面是否可见、CPU的负荷情况等来自行决定最佳的帧速率，从而更合理地使用CPU。 如果想做逐帧动画，就应该用这个方法，这就要求动画函数执行会先于浏览器重绘动作。通常，被调用的频率是每秒60次。 回调函数只会传入一个DOMHighResTimeStamp参数，表示函数队列被触发的时间。 requestAnimationFrame返回一个id，用于window.cancelAnimationFrame(id)来取消这个回调函数 兼容代码： 1234567891011121314151617181920212223242526window.requestAnimationFrame=window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback, element) &#123; var start, finish; window.setTimeout(function () &#123; start = +new Date(); callback(start); finish = +new Date(); self.timeout = 1000 / 60 - (finish - start); &#125;, self.timeout); &#125;; window.cancelNextRequestAnimationFrame = window.cancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout; requestAnimationFrame做的简易动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; *&#123;padding:0;margin: 0&#125; .outer&#123;width: 100px;height: 100px;overflow:hidden;position: relative;&#125; .inner&#123; height:100px;list-style-type:none;width: 400px; &#125; .inner:after&#123;height: 0;content: '';clear: both;visibility: hidden;&#125; .inner li&#123;float: left;width: 100px;height: 100px&#125; li:nth-child(1)&#123;background: red&#125; li:nth-child(2)&#123;background: black&#125; li:nth-child(3)&#123;background: yellow&#125; li:nth-child(4)&#123;background: green&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="outer"&gt; &lt;ul class="inner"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;button&gt;下一步&lt;/button&gt; &lt;script type="text/javascript"&gt; var start = null; var element = document.querySelector('.inner') element.style.position = 'absolute'; var cur=0,mm=100,timeid function step(timestamp) &#123; if (!start) start = timestamp; var progress = timestamp - start; if(cur==3)&#123; element.style.left=0; &#125;else&#123; element.style.left = -Math.min(progress / 10+cur*100, (cur+1)*100) + 'px'; &#125; if (progress &lt; 1000) &#123; timeid=window.requestAnimationFrame(step); &#125;else&#123; cur=cur&lt;3?cur+1:0 window.cancelAnimationFrame(timeid) timeid=null start=null setTimeout(auto,1000) &#125; &#125; var btn=document.querySelector('button') btn.onclick=function()&#123; auto() &#125; function auto()&#123; if(!timeid)&#123; console.log(cur) timeid=window.requestAnimationFrame(step); &#125; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个vue2.0+vuex+vue-router搭建的单页潮流购物网站]]></title>
      <url>%2F2017%2F01%2F22%2Ffashion%2F</url>
      <content type="text"><![CDATA[项目demo地址github源码地址 首页 觉得不错，给我的github源码点个赞吧QAQ 前言这篇文章是总结自己写项目时的思路，遇到的问题，和学到的东西，本文只截取一部分来讲，源码已奉上，觉得项目还行的点个赞吧，谢谢 一、搭建环境 安装vue-cli npm install -g vue-cli 创建webpack项目 vue init webpack voguecd vogue 安装依赖 npm install 安装vue-router npm install vue-router –save-dev 安装vuex npm install vuex –save-dev 运行 npm run dev 二、目录结构 components中是所有页面组件 store中的index.js存放了vuex状态管理的东西，此处本应分成actions.js,mutations.js,getters.js的，可是我试了很多次没成功，还是将他们放在一个文件中，显得有点冗余了，这点失误了，会找原因的 static中存放了图片，图片是压缩了的，网站是https://tinypng.com/，还存放了字体，和一点css，css放在这里有一个原因就是，我想给某个元素设置background时，将style写在static里才行。 dist文件是后来npm run build后生成的，生成的dist中的index.html中的link都是没有加引号的，我自己加上才可以直接运行 三、项目开发开发过程中，页面是一个一个写的，不过还是要先确定路由，路由嵌套 main.js先说说路由吧，写在了main.js中，直接上图 文章开头有首页，home的路径就是’home’，这里路由嵌套，用‘:id’来识别，Brands.vue组件在后文中会解释如何得到id，home页的八个导航，分别导向‘/home’,‘/news’，‘/collections’,‘/shop’,‘/home/clot’,‘/home/madness’,‘/home/bape’,‘/home/assc’,购物车导向‘/cart’,‘login|register’导向‘/login’,‘/newsarticle’是在news组件中导向的，‘/shoppingitem’是shop组件中导向的 App.vue v-for列表渲染的数据如left_navs和contents均来自state 对象迭代 &lt;div v-for=&quot;(value, key, index) in object&quot;&gt; {{ index }}. {{ key }} : {{ value }} &lt;/div&gt; 如何得到state中的数据 1234567891011import &#123;mapGetters&#125; from &apos;vuex&apos; computed:&#123; ...mapGetters(&#123; show:&apos;getShow&apos;, items:&apos;getFootItems&apos;, cart:&apos;getCart&apos;, brands:&apos;getBrands&apos;, left_navs:&apos;getLeft_nav&apos; &#125;) &#125;, 在布局上，我的思路是： 首页三行，上下定高，中间自适应高度，于是在app.vue的created()中设置事件委托 12345678910111213141516171819202122232425262728 var self=this; window.onload=()=&gt;&#123; this.$store.dispatch(&apos;change_hw&apos;,&#123; h:document.documentElement.clientHeight||document.body.clientHeight, w:document.documentElement.clientWidth||document.body.clientWidth &#125;) &#125; window.onresize=()=&gt;&#123; if(self.timer)&#123; clearTimeout(self.timer) &#125; self.timer=setTimeout(function()&#123; self.$store.dispatch(&apos;change_hw&apos;,&#123; h:document.documentElement.clientHeight||document.body.clientHeight, w:document.documentElement.clientWidth||document.body.clientWidth &#125;) &#125;,100) &#125; window.onscroll=()=&gt;&#123; var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop; if(scrollTop&gt;10)&#123; this.scroll=true; &#125;else&#123; this.scroll=false; &#125; &#125;&#125; 然后中间那行用的三栏布局，左右定宽中间自适应宽度，再设置一个min-height不免得将中间的轮播弄来没有了，具体见css 细节： 其中用data中的scroll，用来显示可以让页面一键划到顶端的按钮，滑动动画代码如下 123456789101112131415161718192021222324252627282930313233scrolltoTop:()=&gt;&#123; if(document.documentElement.scrollTop)&#123; var scrollTop=document.documentElement.scrollTop var step=scrollTop/30; var now=scrollTop-step; var i=0; var time=setInterval(function()&#123; i++; if(i&gt;32)&#123; clearInterval(time) &#125; document.documentElement.scrollTop=now; scrollTop=document.documentElement.scrollTop now=scrollTop-step; &#125;,10) &#125;else if(document.body.scrollTop)&#123; var scrollTop=document.body.scrollTop var step=scrollTop/30; var now=scrollTop-step; var i=0; var time=setInterval(function()&#123; i++; if(i&gt;32)&#123; clearInterval(time) &#125; document.body.scrollTop=now; scrollTop=document.body.scrollTop now=scrollTop-step; &#125;,10) &#125; &#125;, 这里比较坑的地方就是document.documentElement.scrollTop和document.documentElement.scrollTop需要注意 Home.vue这里给出了brands的样式，也就是说导航栏的home，clot，madness，bape，assc都有这个组件， HomeFirst.vue2.21号修改重新改了下轮播，通过改变left来实现无限轮播，思路如下： 123456789&lt;div class=&quot;wrapper-content&quot; :class=&quot;&#123;wrapper_trans:isTrans&#125;&quot; :style=&quot;&#123;width:originalData.img_width*(originalData.num+2)+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;,left:-originalData.img_width+&apos;px&apos;&#125;&quot; ref=&quot;wrapperContent&quot;&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; :src=&quot;&apos;../static/images/home_4.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; :src=&quot;&apos;../static/images/home_1.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;2&quot; :src=&quot;&apos;../static/images/home_2.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;3&quot; :src=&quot;&apos;../static/images/home_3.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;4&quot; :src=&quot;&apos;../static/images/home_4.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt; &lt;img class=&quot;wrapper-content_img&quot; alt=&quot;1&quot; :src=&quot;&apos;../static/images/home_1.jpg&apos;&quot; :style=&quot;&#123;width:originalData.img_width+&apos;px&apos;,height:originalData.img_height+&apos;px&apos;&#125;&quot;/&gt;&lt;/div&gt; 共四张图片，前后再加一张，变成六张，当向后滚动到第五张时，index为4，下一次滚动，滚动到第六张结束后立即跳到第二张，index依然为3。向前滑动道理一样 methods如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130export default &#123; data ()&#123; return &#123; originalData:&#123; img_width:350, img_height:350, btn_width:40, btn_height:40, num:4, delay:300 &#125;, isTrans:true,//因为到最后一张图片，index为1时，需要立即跳到第二张index也为1的图片，这个用来是否给出transition index:1, timer:null,//setInterval clickdelay:false//用来防止连续点击 &#125; &#125;, computed:&#123; ...mapGetters(&#123; hw:&apos;getHW&apos; &#125;), home_first_width:function()&#123; return parseInt(this.hw.w)-400; &#125;, home_first_height:function()&#123; var a= parseInt(this.hw.h)-200 return a&lt;389?389:a &#125;, home_first_height_margin:function()&#123; return parseInt(this.home_first_height-300)/2 &#125; &#125;, methods:&#123; next()&#123; if(this.clickdelay)&#123; return &#125; this.clickdelay=true if(this.index==this.originalData.num)&#123; this.index=1 &#125;else&#123; this.index+=1 &#125; this.animate(this.originalData.img_width) &#125;, prev()&#123; if(this.clickdelay)&#123; return &#125; this.clickdelay=true if(this.index==1)&#123; this.index=this.originalData.num &#125;else&#123; this.index-=1 &#125; this.animate(-this.originalData.img_width) &#125;, animate(offset)&#123; var node=this.$refs.wrapperContent var self=this; var left=parseInt(node.style.left)-offset this.isTrans=true node.style.left=left+&apos;px&apos; setTimeout(function()&#123; if(left&lt;-(self.originalData.num*self.originalData.img_width))&#123; self.isTrans=false node.style.left=-self.originalData.img_width+&apos;px&apos; self.clickdelay=false //当到达最后一张图片时 &#125; if(left&gt;-100)&#123; self.isTrans=false node.style.left=-self.originalData.num*self.originalData.img_width+&apos;px&apos; self.clickdelay=false //当到达第一张图片时 &#125; &#125;,this.originalData.delay) &#125;, play()&#123; var self=this; this.timer=setInterval(function()&#123; self.next() &#125;,2000) &#125;, stop()&#123; this.clickdelay=false//用来防止连续点击 clearInterval(this.timer) this.timer=null &#125;, turnTo(flag)&#123; if(flag==this.index)&#123; return &#125;else&#123; var offset=(flag-this.index)*this.originalData.img_width this.index=flag this.animate(offset) &#125; &#125; &#125;, mounted()&#123; /*下面是判断过渡动画是否完成*/ var node=this.$refs.wrapperContent var transitions = &#123; &apos;transition&apos;:&apos;transitionend&apos;, &apos;OTransition&apos;:&apos;oTransitionEnd&apos;, &apos;MozTransition&apos;:&apos;transitionend&apos;, &apos;WebkitTransition&apos;:&apos;webkitTransitionEnd&apos; &#125; var self=this for(var t in transitions)&#123; if( node.style[t] !== undefined )&#123; var transitionEvent=transitions[t]; &#125; &#125; transitionEvent &amp;&amp; node.addEventListener(transitionEvent, function() &#123; self.clickdelay=false &#125;); this.play() &#125;, created()&#123; this.$store.dispatch(&apos;changeShow&apos;,&apos;home&apos;) &#125; &#125; Shop.vue1234567891011121314 methods:&#123; changeLike(index)&#123; this.$store.dispatch(&apos;changeLike&apos;,index)//改变是否喜欢 &#125;, changeFlagTrue(index)&#123; this.$store.dispatch(&apos;changeFlagTrue&apos;,index)//改变是否显示喜欢 &#125;, changeFlagFalse(index)&#123; this.$store.dispatch(&apos;changeFlagFalse&apos;,index)//改变是否显示喜欢 &#125;, changeSelectedItem(index)&#123; this.$store.dispatch(&apos;changeSelectedItem&apos;,index)//改变进入商品 &#125;&#125; 每个商品被点击时都要改变进入的是哪个商品，changeSelectedItem来完成，这个页面想法来源于1626潮牌网，觉得挺好看的，于是自己写了下来，尤其是mouseover显示的是否喜欢，处理的还是可以，不过chrome和Firefox还是会有闪烁的效果没有处理好 shoppingitem.vue这个组件中重要的就是数量的增减，因为每个商品都有一个对象存储数据，并且加入购物车还需要判断购物车中是否有相同信息的商品，还有点击加入购物车后直接跳转到购物车页面，方法如下123456789101112131415161718192021222324 methods:&#123; changeSize(index)&#123; this.$store.dispatch(&apos;changeSize&apos;,index) &#125;, changeColor(num)&#123; this.$store.dispatch(&apos;changeColor&apos;,num) &#125;, changeNumSub()&#123; if(this.item.num&gt;1)&#123; this.$store.dispatch(&apos;changeNumSub&apos;) &#125; &#125;, changeNumAdd()&#123; if(this.item.num&lt;8)&#123; this.$store.dispatch(&apos;changeNumAdd&apos;) &#125; &#125;, addToCart()&#123; if(!!this.item.color&amp;&amp;!!this.item.size)&#123; this.$store.dispatch(&apos;addToCart&apos;) &#125; &#125;&#125; index.js中的方法如下1234567891011121314151617181920212223242526272829ADD_TO_CART(state)&#123; var cart=state.cart; var thing=mutations.clone(state.selectedItem); //查看购物车是否已经有相同的商品，信息都一样 if(!cart.length)&#123; cart.push(thing) &#125;else&#123; var flag=cart.some(function(e)&#123; return e.color==thing.color&amp;&amp;e.size==thing.size&amp;&amp;e.src==thing.src &#125;) try&#123; if(!flag)&#123; cart.push(thing); throw new Error(&quot;can&apos;t find&quot;) &#125; cart.forEach(function(e,index)&#123; if(e.color==thing.color&amp;&amp;e.size==thing.size&amp;&amp;e.src==thing.src)&#123; cart[index].num+=thing.num; foreach.break=new Error(&quot;StopIteration&quot;); &#125; &#125;) &#125;catch(e)&#123; //用于跳出循环 &#125; &#125; state.selectedItem=&#123;&#125;; &#125;, 添加到购物车中的方法中，我用try，catch来跳出forEach循环，还有这句state.selectedItem={};如果state.selectedItem是直接引用别的对象，那么另一个对象也会跟着改变，为了避免引用，我用了如下方法 123456789101112//js复制对象 clone(myObj)&#123; if(typeof(myObj) != &apos;object&apos;) return myObj; if(myObj == null) return myObj; var myNewObj = new Object(); for(var i in myObj) myNewObj[i] = mutations.clone(myObj[i]); return myNewObj; &#125;, Brands.vue 在created(){}中用this.$route.params.id来得到进入那个路由,因为这四个brand布局样式什么的大致都一样，然后watch来检测this.$route.params.id的改变，以此来getIntro也就是每个brand的数据 组件的介绍大致就是这些 四、Vuex我在vuex这里没有做好，状态和数据应该分开，而且actions，mutations，getters，state，应该分开，不然太冗余了 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。这个状态自管理应用包含以下几个部分：state，驱动应用的数据源；view，以声明方式将state映射到视图；actions，响应在view上的用户输入导致的状态变化。 index.js中的state大概罗列一点123456789101112131415161718const state=&#123; loginway:&apos;&apos;, show:&apos;home&apos;, clientheight:0, clientwidth:0, footItems:[ &#123;title:&apos;ABOUT US&apos;,contents:&#123;content_1:&apos;contact us&apos;,content_2:&apos;about vogue&apos;&#125;&#125;, &#123;title:&apos;SERVICE&apos;,contents:&#123;content_1:&apos;payment methods&apos;,content_2:&apos;track order&apos;&#125;&#125;, &#123;title:&apos;POLICY&apos;,contents:&#123;content_1:&apos;privacy policy&apos;,content_2:&apos;terms &amp; condition&apos;&#125;&#125;, &#123;title:&apos;FOLLOW US&apos;,contents:&#123;content_1:&apos;Facebook&apos;,content_2:&apos;Instagram&apos;&#125;&#125;, ], left_nav:&#123; home:&apos;home&apos;, news:&apos;news&apos;, collections:&apos;collections&apos;, shop:&apos;shop&apos; &#125;,] index.js中的mutations1234567891011121314151617181920const mutations=&#123; CHANGE_HW(state,obj)&#123; state.clientwidth=obj.w; state.clientheight=obj.h; &#125;, CHANGE_SHOW(state,type)&#123; state.show=type &#125;, CHANGE_NOWBRAND(state,type)&#123; state.nowbrand=type+&apos;Intro&apos; &#125;, CHANGE_LIKE(state,index)&#123; state.goods[index].isLike=!state.goods[index].isLike; if(!state.goods[index].isLike)&#123; state.goods[index].likes+=1 &#125;else&#123; state.goods[index].likes-=1 &#125; &#125;,&#125; 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： index.js中的actions1234567891011121314const actions=&#123; change_hw(&#123;commit&#125;,obj)&#123; commit(&apos;CHANGE_HW&apos;,obj) &#125;, changeShow(&#123;commit&#125;,type)&#123; commit(&apos;CHANGE_SHOW&apos;,type) &#125;, changeNowbrand(&#123;commit&#125;,type)&#123; commit(&apos;CHANGE_NOWBRAND&apos;,type) &#125;, changeLike(&#123;commit&#125;,index)&#123; commit(&apos;CHANGE_LIKE&apos;,index) &#125;,&#125; Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 index.js中的getters1234567891011121314151617const getters=&#123; getHW:function(state)&#123; return &#123; h:state.clientheight, w:state.clientwidth &#125; &#125;, getBrands:function(state)&#123; return state.brandsArr &#125;, getLeft_nav:function(state)&#123; return state.left_nav &#125;, getShow:function(state)&#123; return state.show &#125;&#125; 有时候我们需要从 store 中的 state 中派生出一些状态,或用于得到信息 五、总结自己写的这个项目，蛮有收获的，遇到了问题到处问，都解决的差不多了，下面罗列了一些收货和本项目的不足 Firefox中不支持 table 的 min-height CSS 的话 考虑用 normalize.css解决不同浏览器初始样式不一样的问题 css 的命名啥的可以参考一下 BEM 的命名规范 代码组织有点杂乱 vuex只要专心做页面状态管理，尽量不要掺杂页面数据 &lt;input type=&quot;checkbox&quot; @change=&quot;selectAll&quot; id=&quot;selectAll&quot; v-model=&quot;isAll&quot;/&gt;此处的isAll是从state中get到得数据，可以被改变，我自己尝试得到的这个结论 轮播还需要改进 第一次在gh-pages中显示时，发现图片加载太慢 ，于是我把图片压缩了 在用git上传代码是出过差错，解决了。 最后感谢您能阅读到这里，本人小白，努力学习中，献丑了。 参考资料 Vue2.0中文文档：https://cn.vuejs.org/ Vue-router2.0中文文档：http://router.vuejs.org/zh-cn/essentials/getting-started.html Vuex2.0中文文档：http://router.vuejs.org/zh-cn/essentials/getting-started.html git教程：http://www.liaoxuefeng.com/]]></content>
    </entry>

    
  
  
</search>
